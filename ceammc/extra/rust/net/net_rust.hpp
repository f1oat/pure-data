#ifndef ceammc_rust_net_h
#define ceammc_rust_net_h

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <cstdint>
#include <cstddef>


enum class ceammc_http_client_param_type {
    /// header key/value
    Header,
    /// form key/value
    Form,
    /// multipart key/value
    MultiPart,
    /// CSS selector/output type
    Selector,
    /// mime type (for uploading)
    Mime,
    /// username/password
    BasicAuth,
    /// strip whitespaces
    StripWhiteSpaces,
    /// JSON response parse
    JsonParse,
};

enum class ceammc_http_content_type {
    None,
    Html,
    Json,
};

enum class ceammc_mqtt_qos {
    /// may lose messages
    AtMostOnce = 0,
    /// guarantees the message delivery but potentially exists duplicate messages
    AtLeastOnce = 1,
    /// ensures that messages are delivered exactly once without duplication
    ExactlyOnce = 2,
};

enum class ceammc_mqtt_rc {
    Success = 0,
    RefusedProtocolVersion,
    BadClientId,
    ServiceUnavailable,
    BadUserNamePassword,
    NotAuthorized,
};

enum class ceammc_ws_client_selector {
    ALL,
    FIRST,
    LAST,
    ID,
    EXCEPT,
};

enum class ceammc_ws_rc {
    Ok = 0,
    InvalidClient,
    InvalidServer,
    InvalidMessage,
    InvalidData,
    InvalidClientId,
    SendError,
    NoData,
    CloseError,
    ConnectionClosed,
    NonBlockingError,
    SocketAcceptError,
    SocketReadError,
    SocketDeferClose,
    RunloopExit,
};

struct ceammc_freesound_client;

struct ceammc_http_client;

struct ceammc_mqtt_client;

struct ceammc_telegram_bot_client;

struct ceammc_ws_client;

struct ceammc_ws_server;

struct ceammc_freesound_init {
    const char *token;
};

struct ceammc_callback_msg {
    void *user;
    void (*cb)(void *user, const char *msg);
};

struct ceammc_callback_progress {
    void *user;
    void (*cb)(void *user, uint8_t msg);
};

struct ceammc_freesound_search_result {
    /// The soundâ€™s unique identifier.
    uint64_t id;
    /// The URI for this sound on the Freesound website.
    const char *url;
    /// The name user gave to the sound.
    const char *name;
    /// The license under which the sound is available to you.
    const char *license;
    /// The type of sound (wav, aif, aiff, mp3, m4a or flac).
    const char *file_type;
    /// The number of channels.
    uint8_t channels;
    /// The size of the file in bytes.
    uint64_t file_size;
    /// The bit depth of the sound.
    uint8_t bit_depth;
    ///  The duration of the sound in seconds.
    float duration;
    /// The sample_rate of the sound.
    float sample_rate;
};

struct ceammc_freesound_result_cb {
    void *user;
    void (*cb_oauth_url)(void *user, const char *url);
    void (*cb_oauth_access)(void *user, const char *token, uint64_t expires);
    void (*cb_info_me)(void *user, uint64_t id, const char *username, const char *email, const char *homepage, const char *url, const char *sounds, const char *packs);
    void (*cb_search_info)(void *user, uint64_t count, uint32_t prev, uint32_t next);
    void (*cb_search_result)(void *user, size_t i, const ceammc_freesound_search_result *res);
};

struct ceammc_callback_notify {
    size_t id;
    void (*cb)(size_t id);
};

struct ceammc_freesound_search_params {
    const char *query;
    const char *filter;
    const char *sort;
    const char *const *fields;
    size_t num_fields;
    const char *const *descriptors;
    size_t num_descriptors;
    int16_t page;
    int8_t page_size;
    bool normalized;
    bool group_by_pack;
};

struct ceammc_http_client_param {
    /// param name or key
    const char *name;
    /// param value
    const char *value;
    /// parameter type
    ceammc_http_client_param_type param_type;
};

struct ceammc_http_client_init {
    const void *_dummy;
};

struct ceammc_http_client_result {
    /// reply text (can be NULL!)
    const char *data;
    /// requested output content type
    ceammc_http_content_type content_type;
    /// HTTP status
    uint16_t status;
};

struct ceammc_http_client_result_cb {
    /// user data pointer (can be NULL)
    void *user;
    /// callback function (can be NULL)
    void (*cb)(void *user, const ceammc_http_client_result*);
};

struct ceammc_mqtt_client_init {
    const char *url;
    const char *id;
};

struct ceammc_mqtt_client_result_cb {
    /// user data pointer (can be NULL)
    void *user;
    /// ping callback function (can be NULL)
    void (*ping_cb)(void *user);
    /// connected callback function (can be NULL)
    void (*conn_cb)(void *user, ceammc_mqtt_rc code);
    /// publish callback function (can be NULL)
    void (*pub_cb)(void *user, const char *topic, const uint8_t *data, size_t data_len, ceammc_mqtt_qos qos, bool retain, uint16_t pkid);
};

struct ceammc_telegram_bot_init {
    /// telegram bot TOKEN
    const char *token;
};

struct ceammc_telegram_bot_result_cb {
    /// user data pointer (can be NULL)
    void *user;
    /// connection callback function (can be NULL)
    void (*whoami_cb)(void *user, uint64_t user_id, const char *username);
    /// text callback function (can be NULL)
    void (*text_cb)(void *user, int64_t chat_id, int32_t msg_id, const char *text);
    /// location callback function (can be NULL)
    void (*loc_cb)(void *user, int64_t chat_id, double latitude, double longitude);
    /// sticker callback function (can be NULL)
    void (*sti_cb)(void *user, int64_t chat_id, const char *file_id, const char *emoji);
    /// voice callback function (can be NULL)
    void (*voice_cb)(void *user, int64_t chat_id, const char *file_id, const char *file_unique_id, const char *mime, uint32_t file_duration, uint64_t file_size);
    /// voice callback function (can be NULL)
    void (*audio_cb)(void *user, int64_t chat_id, const char *file_id, const char *file_unique_id, const char *mime, const char *file_name, uint32_t file_duration, uint64_t file_size, const char *title);
};

struct ceammc_ws_client_init {
    /// websocket url in format: ws://HOST:PORT/PATH?
    const char *url;
};

struct ceammc_ws_client_result_cb {
    /// user data pointer (can be NULL)
    void *user;
    /// text data callback function (can be NULL)
    void (*cb_text)(void *user, const char *txt);
    /// binary data callback function (can be NULL)
    void (*cb_binary)(void *user, const uint8_t *data, size_t data_len);
    /// ping callback function (can be NULL)
    void (*cb_ping)(void *user, const uint8_t *data, size_t data_len);
    /// pong callback function (can be NULL)
    void (*cb_pong)(void *user, const uint8_t *data, size_t data_len);
    /// close callback function (can be NULL)
    void (*cb_close)(void *user);
    /// connected/disconnected callback function (can be NULL)
    void (*cb_connected)(void *user, bool state);
};

struct ceammc_ws_client_target {
    ceammc_ws_client_selector sel;
    size_t id;
};

struct ceammc_ws_conn_info {
    const char *addr;
    size_t id;
};

struct ceammc_ws_srv_on_text {
    void *user;
    void (*cb)(void *user, const char *msg, const ceammc_ws_conn_info *info);
};

struct ceammc_ws_srv_on_data {
    void *user;
    void (*cb)(void *user, const uint8_t *msg, size_t len, const ceammc_ws_conn_info *info);
};

struct ceammc_ws_srv_on_cli {
    void *user;
    void (*cb)(void *user, const ceammc_ws_conn_info *info);
};


extern "C" {

/// free freesound client
/// @param fs - pointer to freesound client (can be NULL)
void ceammc_freesound_free(ceammc_freesound_client *fs);

bool ceammc_freesound_me(const ceammc_freesound_client *cli, const char *access);

/// create new freesound client
/// @param params - connection params
/// @param cb_err - called in the main thread on error message
/// @param cb_post - called in the main thread on post message
/// @param cb_debug - called in the main thread on debug message
/// @param cb_log - called in the main thread on log message
/// @param cb_progress - called in the main thread on progress message
/// @param cb_reply - called in the main thread on result reply message
/// @param cb_notify - called in the worker thread (!) to notify main thread
/// @return pointer to new client or NULL on error
[[nodiscard]]
ceammc_freesound_client *ceammc_freesound_new(ceammc_freesound_init params,
                                              ceammc_callback_msg cb_err,
                                              ceammc_callback_msg cb_post,
                                              ceammc_callback_msg cb_debug,
                                              ceammc_callback_msg cb_log,
                                              ceammc_callback_progress cb_progress,
                                              ceammc_freesound_result_cb cb_reply,
                                              ceammc_callback_notify cb_notify);

bool ceammc_freesound_oauth_get_access(const ceammc_freesound_client *cli,
                                       const char *id,
                                       const char *secret,
                                       const char *auth_code);

bool ceammc_freesound_oauth_get_code(const ceammc_freesound_client *cli,
                                     const char *id,
                                     const char *secret);

bool ceammc_freesound_oauth_load_access_token(const ceammc_freesound_client *cli,
                                              const char *base_dir);

bool ceammc_freesound_oauth_store_access_token(const ceammc_freesound_client *cli,
                                               const char *auth_token,
                                               const char *base_dir,
                                               bool overwrite);

/// process all results that are ready
/// @param cli - freesound client pointer
/// @return true on success, false on error
bool ceammc_freesound_process(ceammc_freesound_client *cli);

bool ceammc_freesound_search(const ceammc_freesound_client *cli,
                             const char *access,
                             ceammc_freesound_search_params params);

/// download file with GET request
/// @param cli - http client pointer
/// @param url - requested URL
/// @param file - output filename (if NULL - try to auto detect)
/// @param dir - base directory to save if filename is not absolute
/// @param param - pointer to array of request parameters (can be NULL)
/// @param param_len - array size of request parameters
/// @return true on success, false on error
bool ceammc_http_client_download(ceammc_http_client *cli,
                                 const char *url,
                                 const char *file,
                                 const char *dir,
                                 const ceammc_http_client_param *params,
                                 size_t params_len);

/// free http client
/// @param cli - pointer to http client (can be NULL)
void ceammc_http_client_free(ceammc_http_client *cli);

/// do http get request
/// @param cli - http client pointer
/// @param url - requested URL
/// @param param - pointer to array of request parameters (can be NULL)
/// @param param_len - array size of request parameters
/// @return true on success, false on error
bool ceammc_http_client_get(ceammc_http_client *cli,
                            const char *url,
                            const ceammc_http_client_param *param,
                            size_t param_len);

/// create new http client
/// @param _params - unused
/// @param cb_err - called in the main thread on error message
/// @param cb_post - called in the main thread on post message
/// @param cb_debug - called in the main thread on debug message
/// @param cb_log - called in the main thread on log message
/// @param cb_progress - called in the main thread on progress message
/// @param cb_reply - called in the main thread on result reply message
/// @param cb_notify - called in the worker thread (!) to notify main thread
/// @return pointer to new client or NULL on error
[[nodiscard]]
ceammc_http_client *ceammc_http_client_new(ceammc_http_client_init _params,
                                           ceammc_callback_msg cb_err,
                                           ceammc_callback_msg cb_post,
                                           ceammc_callback_msg cb_debug,
                                           ceammc_callback_msg cb_log,
                                           ceammc_callback_progress cb_progress,
                                           ceammc_http_client_result_cb cb_reply,
                                           ceammc_callback_notify cb_notify);

/// do http post request
/// @param cli - http client pointer
/// @param url - requested URL
/// @param param - pointer to array of request parameters (can be NULL)
/// @param param_len - array size of request parameters
/// @return true on success, false on error
bool ceammc_http_client_post(ceammc_http_client *cli,
                             const char *url,
                             const ceammc_http_client_param *param,
                             size_t param_len);

/// process all results that are ready
/// @param cli - http client pointer
/// @return true on success, false on error
bool ceammc_http_client_process(ceammc_http_client *cli);

/// upload file with POST request
/// @param cli - http client pointer
/// @param url - requested URL
/// @param file - filename
/// @param file_key - file part name in multipart data
/// @param param - pointer to array of request parameters (can be NULL)
/// @param param_len - array size of request parameters
/// @return true on success, false on error
bool ceammc_http_client_upload(ceammc_http_client *cli,
                               const char *url,
                               const char *file,
                               const char *file_key,
                               const ceammc_http_client_param *params,
                               size_t params_len);

void ceammc_init_rust_logging();

/// free mqtt client
/// @param cli - mqtt client (can be NULL)
void ceammc_mqtt_client_free(ceammc_mqtt_client *cli);

/// create new mqtt client
/// @param url - mqtt broker url in format mqtt://host:port
/// @param id - client id (can be NULL)
/// @param cb - callbacks
/// @return pointer to mqtt_client (must be freed by ceammc_mqtt_client_free()) on success
///         or NULL on error
ceammc_mqtt_client *ceammc_mqtt_client_new(ceammc_mqtt_client_init params,
                                           ceammc_callback_msg cb_err,
                                           ceammc_callback_msg cb_post,
                                           ceammc_callback_msg cb_debug,
                                           ceammc_callback_msg cb_log,
                                           ceammc_callback_progress _cb_progress,
                                           ceammc_mqtt_client_result_cb cb_reply,
                                           ceammc_callback_notify cb_notify);

/// iterate mqtt events
/// @param cli - mqtt client pointer
/// @return true on success
bool ceammc_mqtt_client_process(ceammc_mqtt_client *cli);

/// publish text message into mqtt topic
/// @param topic - mqtt topic ('+' single layer wildcard, '#' recursive layer wildcard)
/// @param msg - mqtt message
/// @param qos - Quality of Service flag
/// @param retain - This flag tells the broker to store the message for a topic
///        and ensures any new client subscribing to that topic will receive the stored message.
/// @return true on success
bool ceammc_mqtt_client_publish(ceammc_mqtt_client *cli,
                                const char *topic,
                                const char *msg,
                                ceammc_mqtt_qos qos,
                                bool retain);

/// publish binary data into mqtt topic
/// @param topic - mqtt topic ('+' single layer wildcard, '#' recursive layer wildcard)
/// @param data - mqtt binary data
/// @param len - mqtt binary data length
/// @param qos - Quality of Service flag
/// @param retain - This flag tells the broker to store the message for a topic
///        and ensures any new client subscribing to that topic will receive the stored message
/// @return true on success
bool ceammc_mqtt_client_publish_data(ceammc_mqtt_client *cli,
                                     const char *topic,
                                     const uint8_t *data,
                                     size_t len,
                                     ceammc_mqtt_qos qos,
                                     bool retain);

/// subscribe to mqtt topic
/// @param cli - mqtt client
/// @param topic - mqtt topic
/// @return true on success
bool ceammc_mqtt_client_subscribe(ceammc_mqtt_client *cli, const char *topic, ceammc_mqtt_qos qos);

/// unsubscribe from mqtt topic
/// @param cli - mqtt client
/// @param topic - mqtt topic
/// @return true on success
bool ceammc_mqtt_client_unsubscribe(ceammc_mqtt_client *cli, const char *topic);

/// free telegram bot
/// @param cli - pointer to telegram bot
void ceammc_telegram_bot_free(ceammc_telegram_bot_client *cli);

/// get file from telegram bot
/// @param cli - pointer to telegram bot
bool ceammc_telegram_bot_get_file(ceammc_telegram_bot_client *cli,
                                  const char *file_id,
                                  const char *base_dir);

/// logout telegram bot
/// @param cli - pointer to telegram bot
bool ceammc_telegram_bot_logout(ceammc_telegram_bot_client *cli);

/// create new telegram bot
/// @param params - telegram init settings
/// @param cb_err - callback called on error
/// @param cb_post - callback called on post
/// @param cb_debug - callback called on debug
/// @param cb_log - callback called on log
/// @param _cb_progress - not used
/// @param cb_reply - reply callback
/// @param cb_notify - callback called to notify that it's time to check results
/// @return pointer to telegram bot handle or NULL on error
ceammc_telegram_bot_client *ceammc_telegram_bot_new(ceammc_telegram_bot_init params,
                                                    ceammc_callback_msg cb_err,
                                                    ceammc_callback_msg cb_post,
                                                    ceammc_callback_msg cb_debug,
                                                    ceammc_callback_msg cb_log,
                                                    ceammc_callback_progress _cb_progress,
                                                    ceammc_telegram_bot_result_cb cb_reply,
                                                    ceammc_callback_notify cb_notify);

/// process telegram events
/// @param cli - pointer to telegram bot
bool ceammc_telegram_bot_process(ceammc_telegram_bot_client *cli);

/// send audio from telegram bot
/// @param cli - pointer to telegram bot
/// @param chat_id - target chat id
/// @param file - full path to the file
bool ceammc_telegram_bot_send_audio(ceammc_telegram_bot_client *cli,
                                    int64_t chat_id,
                                    const char *file);

/// send text message from telegram bot
/// @param cli - pointer to telegram bot
/// @param chat_id - target chat id
/// @param msg_id - reply message id
/// @param text - message text
/// @return true on success
bool ceammc_telegram_bot_send_message(ceammc_telegram_bot_client *cli,
                                      int64_t chat_id,
                                      int32_t msg_id,
                                      const char *text);

/// send voice from telegram bot
/// @param cli - pointer to telegram bot
/// @param chat_id - target chat id
/// @param file - full path to the file
bool ceammc_telegram_bot_send_voice(ceammc_telegram_bot_client *cli,
                                    int64_t chat_id,
                                    const char *file);

/// send text message from telegram bot
/// @param cli - pointer to telegram bot
bool ceammc_telegram_bot_whoami(ceammc_telegram_bot_client *cli);

/// close websocket client connection
/// @param cli - pointer to websocket client
/// @return true on success, false on error
bool ceammc_ws_client_close(ceammc_ws_client *cli);

/// flush websocket client connection
/// @param cli - pointer to websocket client
/// @return true on success, false on error
bool ceammc_ws_client_flush(ceammc_ws_client *cli);

/// free websocket client
/// @param cli - pointer to websocket client
void ceammc_ws_client_free(ceammc_ws_client *cli);

/// create websocket client
/// @param params - connection params
/// @param cb_err - callback for error messages
/// @param cb_post - callback for post messages
/// @param cb_debug - callback for debug messages
/// @param cb_log - callback for log messages
/// @param _cb_progress - unused
/// @param cb_reply - reply callbacks
/// @param cb_notify - notification callback
/// @return pointer to websocket client or NULL on error
ceammc_ws_client *ceammc_ws_client_new(ceammc_ws_client_init params,
                                       ceammc_callback_msg cb_err,
                                       ceammc_callback_msg cb_post,
                                       ceammc_callback_msg cb_debug,
                                       ceammc_callback_msg cb_log,
                                       ceammc_callback_progress _cb_progress,
                                       ceammc_ws_client_result_cb cb_reply,
                                       ceammc_callback_notify cb_notify);

/// process all available results from websocket
/// @param cli - pointer to websocket client
/// @return true on success, false on error
bool ceammc_ws_client_process_events(ceammc_ws_client *cli);

/// sends binary message to WebSocket server
/// @param cli - pointer to ws client
/// @param data - data pointer
/// @param len - data length
/// @param flush - if true ensures all messages
///        previously passed to write and automatic queued pong responses are written & flushed into the underlying stream.
/// @return true on success, false on error
bool ceammc_ws_client_send_binary(ceammc_ws_client *cli,
                                  const uint8_t *data,
                                  size_t len,
                                  bool flush);

/// sends ping to websocket server
/// @param cli - pointer to websocket client
/// @param data - pointer to ping data (can be NULL)
/// @param len - data length
/// @return true on success, false on error
bool ceammc_ws_client_send_ping(ceammc_ws_client *cli, const uint8_t *data, size_t len);

/// sends text message to WebSocket server
/// @param cli - pointer to ws client
/// @param msg - text message
/// @param flush - if true ensures all messages
///        previously passed to write and automatic queued pong responses are written & flushed into the underlying stream.
/// @return true on success, false on error
bool ceammc_ws_client_send_text(ceammc_ws_client *cli,
                                const char *msg,
                                bool flush);

/// close websocket server client connections by sending them close handshake
/// @param srv - pointer to websocket server
/// @param target - specify target clients
/// @return ceammc_ws_rc
ceammc_ws_rc ceammc_ws_server_close_clients(ceammc_ws_server *srv, ceammc_ws_client_target target);

/// request connected client id
/// @param srv - pointer to server
/// @param cb - request callback
/// @return ceammc_ws_rc
ceammc_ws_rc ceammc_ws_server_connected_clients(ceammc_ws_server *srv,
                                                void *user,
                                                void (*cb)(void *user, const ceammc_ws_conn_info *msg, size_t len));

ceammc_ws_server *ceammc_ws_server_create(const char *addr,
                                          ceammc_ws_srv_on_text on_err,
                                          ceammc_ws_srv_on_text on_txt,
                                          ceammc_ws_srv_on_data on_bin,
                                          ceammc_ws_srv_on_data on_ping,
                                          ceammc_ws_srv_on_cli on_conn,
                                          ceammc_ws_srv_on_cli on_disc);

/// free websocket server
/// @param src - pointer to server
void ceammc_ws_server_free(ceammc_ws_server *srv);

/// process server events (non-blocking) and execute callbacks
/// @param srv - pointer to websocket server
ceammc_ws_rc ceammc_ws_server_process_events(ceammc_ws_server *srv);

/// send binary message to connected clients
/// @param srv - pointer to websocket server
/// @param data - pointer to data
/// @param len - data length
/// @param target - specify target clients
/// @return ceammc_ws_rc
ceammc_ws_rc ceammc_ws_server_send_binary(ceammc_ws_server *srv,
                                          const uint8_t *data,
                                          size_t len,
                                          ceammc_ws_client_target target);

/// send ping message to connected clients
/// @param srv - pointer to websocket server
/// @param data - pointer to data
/// @param len - data length
/// @param target - specify target clients
/// @return ceammc_ws_rc
ceammc_ws_rc ceammc_ws_server_send_ping(ceammc_ws_server *srv,
                                        const uint8_t *data,
                                        size_t len,
                                        ceammc_ws_client_target target);

/// send text message to connected clients
/// @param srv - pointer to websocket server
/// @param msg - text message
/// @param target - specify target clients
/// @return ceammc_ws_rc
ceammc_ws_rc ceammc_ws_server_send_text(ceammc_ws_server *srv,
                                        const char *msg,
                                        ceammc_ws_client_target target);

/// abort all client connections without handshake
/// @param srv - pointer to websocket server
/// @param target - specify target clients
/// @return ceammc_ws_rc
ceammc_ws_rc ceammc_ws_server_shutdown_clients(ceammc_ws_server *srv,
                                               ceammc_ws_client_target target);

} // extern "C"

#endif // ceammc_rust_net_h
