/*****************************************************************************
 * Copyright 2021 Serge Poltavsky. All rights reserved.
 *
 * This file may be distributed under the terms of GNU Public License version
 * 3 (GPL v3) as defined by the Free Software Foundation (FSF). A copy of the
 * license should have been included with this file, or the project in which
 * this file belongs to. You may also find the details of GPL v3 at:
 * http://www.gnu.org/licenses/gpl-3.0.txt
 *
 * If you have any questions regarding the use of this file, feel free to
 * contact the author of this file, or the owner of the project in which
 * this file belongs to.
 *****************************************************************************/
#ifndef RAGEL_COLOR_H
#define RAGEL_COLOR_H

#include <array>
#include <cstddef>
#include <cstdint>

#include <boost/container/small_vector.hpp>

#include "ceammc_atomlist.h"
#include "ragel_common.h"

namespace ceammc {
namespace parser {

    template <size_t N>
    using SmallColorVecN = boost::container::small_vector<uint32_t, N>;
    using SmallColorVec = SmallColorVecN<8>;

    // for autogenerated ragel internals
    struct ColorRagelData {
        int r { 0 };
        int g { 0 };
        int b { 0 };
        int x { 0 };
    };

    struct RgbColor {
        uint8_t r;
        uint8_t g;
        uint8_t b;

        bool operator==(const RgbColor& c) const
        {
            return r == c.r && g == c.g && b == c.b;
        }

        bool operator!=(const RgbColor& c) const { return !operator==(c); }

        uint32_t asInt() const
        {
            return (uint32_t(r) << 16)
                | (uint32_t(g) << 8)
                | uint32_t(b);
        }
    };

    class RgbHexFullMatch {
        int cs { 0 };
        RgbColor color_ { 0, 0, 0 };

    public:
        RgbHexFullMatch();
        void reset();

        t_float asPdColor() const;
        int red() const { return color_.r; }
        int green() const { return color_.g; }
        int blue() const { return color_.b; }

        const RgbColor& color() const { return color_; }
        uint32_t asInt() const { return color_.asInt(); }

        bool parse(const char* str);
        bool parse(const Atom& a);
        size_t parse(const AtomListView& lv, SmallColorVec& out);

        template <size_t N>
        std::array<uint32_t, N> parseN(const AtomListView& lv, const uint32_t& def = 0x000000)
        {
            std::array<uint32_t, N> res;

            const auto M = lv.size();
            for (size_t i = 0; i < N; i++) {
                if (i < M && parse(lv[i]))
                    res[i] = asInt();
                else
                    res[i] = def;
            }

            return res;
        }
    };
}
}

#endif // RAGEL_NUMERIC_H
