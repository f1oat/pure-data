// autogenerated file: do not edit!
#include "wrapper.h"

#include "iface_numeric.h"
extern "C" {
void numeric_setup() {
    post("  library: \"numeric\"");
    post("  version: \"0.1\"");

// iface_numeric.h

    // library: numeric
    WRAP_LIBRARY(numeric, "0.1", "numeric");

    // class: Complex
    WRAP_CLASS(Complex, "complex.new");

    // static method
    using mtype_complex_polar = Complex(*)(float, float);
    WRAP_STATIC_METHOD(Complex, "complex.polar", m_id_complex_polar, mtype_complex_polar, &Complex::polar);

    // method: &Complex::eq
    WRAP_METHOD(Complex, "complex.==", m_id_complex_eq,
        SINGLE_ARG(bool(Complex::*)(const Complex &) const, bool(Complex::*)(float) const), SINGLE_ARG(&Complex::eq, &Complex::eq));

    // method: &Complex::neq
    WRAP_METHOD(Complex, "complex.!=", m_id_complex_neq,
        SINGLE_ARG(bool(Complex::*)(const Complex &) const, bool(Complex::*)(float) const), SINGLE_ARG(&Complex::neq, &Complex::neq));

    // method: &Complex::add
    WRAP_METHOD(Complex, "complex.add", m_id_complex_add,
        SINGLE_ARG(Complex(Complex::*)(const Complex &) const, Complex(Complex::*)(float) const), SINGLE_ARG(&Complex::add, &Complex::add));
    WRAP_METHOD_ALIAS(m_id_complex_add, "complex.+");

    // method: &Complex::sub
    WRAP_METHOD(Complex, "complex.sub", m_id_complex_sub,
        SINGLE_ARG(Complex(Complex::*)(const Complex &) const, Complex(Complex::*)(float) const), SINGLE_ARG(&Complex::sub, &Complex::sub));
    WRAP_METHOD_ALIAS(m_id_complex_sub, "complex.-");

    // method: &Complex::mul
    WRAP_METHOD(Complex, "complex.mul", m_id_complex_mul,
        SINGLE_ARG(Complex(Complex::*)(const Complex &) const, Complex(Complex::*)(float) const), SINGLE_ARG(&Complex::mul, &Complex::mul));
    WRAP_METHOD_ALIAS(m_id_complex_mul, "complex.*");

    // method: &Complex::div
    WRAP_METHOD(Complex, "complex.div", m_id_complex_div,
        SINGLE_ARG(Complex(Complex::*)(const Complex &) const, Complex(Complex::*)(float) const), SINGLE_ARG(&Complex::div, &Complex::div));
    WRAP_METHOD_ALIAS(m_id_complex_div, "complex./");

    // method: &Complex::conj
    WRAP_METHOD(Complex, "complex.conj", m_id_complex_conj,
        SINGLE_ARG(Complex(Complex::*)() const), SINGLE_ARG(&Complex::conj));

    // method: &Complex::abs
    WRAP_METHOD(Complex, "complex.abs", m_id_complex_abs,
        SINGLE_ARG(float(Complex::*)() const), SINGLE_ARG(&Complex::abs));

    // method: &Complex::arg
    WRAP_METHOD(Complex, "complex.arg", m_id_complex_arg,
        SINGLE_ARG(float(Complex::*)() const), SINGLE_ARG(&Complex::arg));

    // method: &Complex::norm
    WRAP_METHOD(Complex, "complex.norm", m_id_complex_norm,
        SINGLE_ARG(float(Complex::*)() const), SINGLE_ARG(&Complex::norm));

    // method: &Complex::real
    WRAP_METHOD(Complex, "complex.real", m_id_complex_real,
        SINGLE_ARG(float(Complex::*)() const), SINGLE_ARG(&Complex::real));

    // method: &Complex::imag
    WRAP_METHOD(Complex, "complex.imag", m_id_complex_imag,
        SINGLE_ARG(float(Complex::*)() const), SINGLE_ARG(&Complex::imag));

    // method: &Complex::exp
    WRAP_METHOD(Complex, "complex.exp", m_id_complex_exp,
        SINGLE_ARG(Complex(Complex::*)() const), SINGLE_ARG(&Complex::exp));

    // method: &Complex::log
    WRAP_METHOD(Complex, "complex.log", m_id_complex_log,
        SINGLE_ARG(Complex(Complex::*)() const), SINGLE_ARG(&Complex::log));
    WRAP_METHOD_ALIAS(m_id_complex_log, "ln");

    // method: &Complex::log10
    WRAP_METHOD(Complex, "complex.log10", m_id_complex_log10,
        SINGLE_ARG(Complex(Complex::*)() const), SINGLE_ARG(&Complex::log10));

    // method: &Complex::pow
    WRAP_METHOD(Complex, "complex.pow", m_id_complex_pow,
        SINGLE_ARG(Complex(Complex::*)(const Complex &) const), SINGLE_ARG(&Complex::pow));

    // method: &Complex::sqrt
    WRAP_METHOD(Complex, "complex.sqrt", m_id_complex_sqrt,
        SINGLE_ARG(Complex(Complex::*)() const), SINGLE_ARG(&Complex::sqrt));

    // method: &Complex::sin
    WRAP_METHOD(Complex, "complex.sin", m_id_complex_sin,
        SINGLE_ARG(Complex(Complex::*)() const), SINGLE_ARG(&Complex::sin));

    // method: &Complex::cos
    WRAP_METHOD(Complex, "complex.cos", m_id_complex_cos,
        SINGLE_ARG(Complex(Complex::*)() const), SINGLE_ARG(&Complex::cos));

    // method: &Complex::tan
    WRAP_METHOD(Complex, "complex.tan", m_id_complex_tan,
        SINGLE_ARG(Complex(Complex::*)() const), SINGLE_ARG(&Complex::tan));

    // method: &Complex::toTuple
    WRAP_METHOD(Complex, "complex.unpack", m_id_complex_totuple,
        SINGLE_ARG(std::tuple<float, float>(Complex::*)() const), SINGLE_ARG(&Complex::toTuple));
    WRAP_METHOD_ALIAS(m_id_complex_totuple, "complex->tuple");

    // method: &Complex::toList
    WRAP_METHOD(Complex, "complex.to_list", m_id_complex_tolist,
        SINGLE_ARG(std::vector<float>(Complex::*)() const), SINGLE_ARG(&Complex::toList));
    WRAP_METHOD_ALIAS(m_id_complex_tolist, "complex->list");


    // class: Rational
    WRAP_CLASS(Rational, "rational.new");

    // method: &Rational::lt
    WRAP_METHOD(Rational, "rational.lt", m_id_rational_lt,
        SINGLE_ARG(bool(Rational::*)(const Rational &) const, bool(Rational::*)(float) const), SINGLE_ARG(&Rational::lt, &Rational::lt));
    WRAP_METHOD_ALIAS(m_id_rational_lt, "rational.<");

    // method: &Rational::gt
    WRAP_METHOD(Rational, "rational.gt", m_id_rational_gt,
        SINGLE_ARG(bool(Rational::*)(const Rational &) const, bool(Rational::*)(float) const), SINGLE_ARG(&Rational::gt, &Rational::gt));
    WRAP_METHOD_ALIAS(m_id_rational_gt, "rational.>");

    // method: &Rational::le
    WRAP_METHOD(Rational, "rational.le", m_id_rational_le,
        SINGLE_ARG(bool(Rational::*)(const Rational &) const, bool(Rational::*)(float) const), SINGLE_ARG(&Rational::le, &Rational::le));
    WRAP_METHOD_ALIAS(m_id_rational_le, "rational.<=");

    // method: &Rational::eq
    WRAP_METHOD(Rational, "rational.==", m_id_rational_eq,
        SINGLE_ARG(bool(Rational::*)(const Rational &) const, bool(Rational::*)(float) const), SINGLE_ARG(&Rational::eq, &Rational::eq));

    // method: &Rational::ge
    WRAP_METHOD(Rational, "rational.ge", m_id_rational_ge,
        SINGLE_ARG(bool(Rational::*)(const Rational &) const, bool(Rational::*)(float) const), SINGLE_ARG(&Rational::ge, &Rational::ge));
    WRAP_METHOD_ALIAS(m_id_rational_ge, "rational.>=");

    // method: &Rational::neq
    WRAP_METHOD(Rational, "rational.!=", m_id_rational_neq,
        SINGLE_ARG(bool(Rational::*)(const Rational &) const, bool(Rational::*)(float) const), SINGLE_ARG(&Rational::neq, &Rational::neq));

    // method: &Rational::add
    WRAP_METHOD(Rational, "rational.add", m_id_rational_add,
        SINGLE_ARG(Rational(Rational::*)(const Rational &) const, Rational(Rational::*)(int) const), SINGLE_ARG(&Rational::add, &Rational::add));
    WRAP_METHOD_ALIAS(m_id_rational_add, "rational.+");

    // method: &Rational::sub
    WRAP_METHOD(Rational, "rational.sub", m_id_rational_sub,
        SINGLE_ARG(Rational(Rational::*)(const Rational &) const, Rational(Rational::*)(int) const), SINGLE_ARG(&Rational::sub, &Rational::sub));
    WRAP_METHOD_ALIAS(m_id_rational_sub, "rational.-");

    // method: &Rational::mul
    WRAP_METHOD(Rational, "rational.mul", m_id_rational_mul,
        SINGLE_ARG(Rational(Rational::*)(const Rational &) const, Rational(Rational::*)(int) const), SINGLE_ARG(&Rational::mul, &Rational::mul));
    WRAP_METHOD_ALIAS(m_id_rational_mul, "rational.*");

    // method: &Rational::div
    WRAP_METHOD(Rational, "rational.div", m_id_rational_div,
        SINGLE_ARG(Rational(Rational::*)(const Rational &) const, Rational(Rational::*)(int) const), SINGLE_ARG(&Rational::div, &Rational::div));
    WRAP_METHOD_ALIAS(m_id_rational_div, "rational./");

    // method: &Rational::toTuple
    WRAP_METHOD(Rational, "rational.unpack", m_id_rational_totuple,
        SINGLE_ARG(std::tuple<float, float>(Rational::*)() const), SINGLE_ARG(&Rational::toTuple));
    WRAP_METHOD_ALIAS(m_id_rational_totuple, "rational->tuple");

    // method: &Rational::toList
    WRAP_METHOD(Rational, "rational.to_list", m_id_rational_tolist,
        SINGLE_ARG(std::vector<float>(Rational::*)() const), SINGLE_ARG(&Rational::toList));
    WRAP_METHOD_ALIAS(m_id_rational_tolist, "rational->list");

    // method: &Rational::toFloat
    WRAP_METHOD(Rational, "rational.to_float", m_id_rational_tofloat,
        SINGLE_ARG(float(Rational::*)() const), SINGLE_ARG(&Rational::toFloat));
    WRAP_METHOD_ALIAS(m_id_rational_tofloat, "rational->float");

    // method: &Rational::pow
    WRAP_METHOD(Rational, "rational.pow", m_id_rational_pow,
        SINGLE_ARG(Rational(Rational::*)(int) const), SINGLE_ARG(&Rational::pow));

    // method: &Rational::abs
    WRAP_METHOD(Rational, "rational.abs", m_id_rational_abs,
        SINGLE_ARG(Rational(Rational::*)() const), SINGLE_ARG(&Rational::abs));

    // method: &Rational::reciprocal
    WRAP_METHOD(Rational, "rational.reciprocal", m_id_rational_reciprocal,
        SINGLE_ARG(Rational(Rational::*)() const), SINGLE_ARG(&Rational::reciprocal));
    WRAP_METHOD_ALIAS(m_id_rational_reciprocal, "rational.1/x");

    // static method
    using mtype_rational_floattorational = Rational(*)(float, int);
    WRAP_STATIC_METHOD(Rational, "rational.from_float", m_id_rational_floattorational, mtype_rational_floattorational, &Rational::floatToRational);
    WRAP_METHOD_ALIAS(m_id_rational_floattorational, "float->rational");

}
}