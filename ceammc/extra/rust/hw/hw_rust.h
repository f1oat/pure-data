#ifndef ceammc_rust_hw_h
#define ceammc_rust_hw_h

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <cstdint>
#include <cstddef>
struct ceammc_hw_gamepad;

enum class ceammc_hw_gamepad_btn {
  South,
  East,
  North,
  West,
  C,
  Z,
  LeftTrigger,
  LeftTrigger2,
  RightTrigger,
  RightTrigger2,
  Select,
  Start,
  Mode,
  LeftThumb,
  RightThumb,
  DPadUp,
  DPadDown,
  DPadLeft,
  DPadRight,
  Unknown,
};

enum class ceammc_hw_gamepad_event_axis {
  LeftStickX,
  LeftStickY,
  LeftZ,
  RightStickX,
  RightStickY,
  RightZ,
  DPadX,
  DPadY,
  Unknown,
};

enum class ceammc_hw_gamepad_event_type {
  ButtonPressed,
  ButtonRepeated,
  ButtonReleased,
  ButtonChanged,
  AxisChanged,
  Connected,
  Disconnected,
  Dropped,
};

enum class ceammc_hw_gamepad_powerstate {
  Unknown = 0,
  Wired,
  Discharging,
  Charging,
  Charged,
};

enum class ceammc_hw_gamepad_rc {
  Ok = 0,
  InvalidHandle,
};

struct ceammc_gamepad_err_cb {
  /// pointer to user data
  void *user;
  void (*cb)(void*, const char*);
};

struct ceammc_hw_gamepad_event {
  /// gamepad id
  size_t id;
  ceammc_hw_gamepad_btn button;
  ceammc_hw_gamepad_event_type event;
  ceammc_hw_gamepad_event_axis axis;
  float value;
};

struct ceammc_gamepad_event_cb {
  /// pointer to user data
  void *user;
  void (*cb)(void *user, const ceammc_hw_gamepad_event *event);
};

struct ceammc_hw_gamepad_powerinfo {
  ceammc_hw_gamepad_powerstate state;
  uint8_t data;
};

struct ceammc_gamepad_dev_info {
  /// gamepad name
  const char *name;
  /// gamepad os_name
  const char *os_name;
  /// gamepad id
  size_t id;
  /// gamepad power info
  ceammc_hw_gamepad_powerinfo power;
  /// gamepad vendor id
  uint16_t vid;
  /// gamepad product id
  uint16_t pid;
  /// gamepad is connected
  bool is_connected;
  /// gamepad has force feedback capability
  bool has_ff;
};

struct ceammc_gamepad_listdev_cb {
  void *user;
  void (*cb)(void *user, const ceammc_gamepad_dev_info *info);
};


extern "C" {

/// free gamepad
void ceammc_hw_gamepad_free(ceammc_hw_gamepad *gp);

/// list connected gamepad devices
/// @param gp - gamepad pointer
ceammc_hw_gamepad_rc ceammc_hw_gamepad_list(ceammc_hw_gamepad *gp);

/// create new gamepad
/// @param err_cb - error callback
/// @param event_cb - gamepad event callback
/// @param on_devinfo - gamepad list connected devices callback
/// @return pointer to new gamepad or NULL on error
ceammc_hw_gamepad *ceammc_hw_gamepad_new(ceammc_gamepad_err_cb on_err,
                                         ceammc_gamepad_event_cb on_event,
                                         ceammc_gamepad_listdev_cb on_devinfo);

/// process gamepad events (blocking read)
/// @param gp - gamepad pointer
/// @param time_ms - event read timeout in milliseconds
/// @return ceammc_hw_gamepad_rc
ceammc_hw_gamepad_rc ceammc_hw_gamepad_process_events(ceammc_hw_gamepad *gp, uint64_t time_ms);

} // extern "C"

#endif // ceammc_rust_hw_h
