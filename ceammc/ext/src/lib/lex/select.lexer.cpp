// select.lexer.cpp generated by reflex 3.0.1 from select.l

#define REFLEX_VERSION "3.0.1"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_YYLTYPE             ceammc::select::location
#define REFLEX_OPTION_YYSTYPE             ceammc::select::SelectParser::semantic_type
#define REFLEX_OPTION_bison_cc            true
#define REFLEX_OPTION_bison_cc_namespace  ceammc::select
#define REFLEX_OPTION_bison_cc_parser     SelectParser
#define REFLEX_OPTION_bison_complete      true
#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_freespace           true
#define REFLEX_OPTION_header_file         "select.lexer.h"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               SelectLexer
#define REFLEX_OPTION_namespace           ceammc::select
#define REFLEX_OPTION_noindent            true
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "select.lexer.cpp"
#define REFLEX_OPTION_reentrant           true
#define REFLEX_OPTION_token_eof           ceammc::select::SelectParser::symbol_type(0)
#define REFLEX_OPTION_token_type          ceammc::select::SelectParser::symbol_type
#define REFLEX_OPTION_unicode             true

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "select.l"

    # include <string>
    # include <stdexcept>
    # include <algorithm>
    # include <cstdint>
    # include <boost/container/static_vector.hpp>

    # include "lex/select.parser.hpp"

    using token = ceammc::select::SelectParser::token;


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define WITH_NO_INDENT
#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace ceammc {
namespace select {

class SelectLexer : public reflex::AbstractLexer<reflex::Matcher> {
#line 13 "select.l"

    public:
        enum MatchType : uint8_t {
            MATCH_EQUAL,
            MATCH_EPSILON,
            MATCH_RANGE_OO,
            MATCH_RANGE_CC,
            MATCH_RANGE_OC,
            MATCH_RANGE_CO,
            MATCH_SET,
            MATCH_LESS,
            MATCH_LESS_EQ,
            MATCH_GREATER,
            MATCH_GREATER_EQ
        };

        struct LexerAtom {
            std::string txt;
            bool is_float;
        };

        class MatchData {
            using AtomStaticList = boost::container::static_vector<ceammc::Atom, 32>;
            AtomStaticList data_;
            MatchType type_ = { MATCH_EQUAL };

        public:
            MatchData() {}
            MatchData(size_t n, MatchType t) : data_(n, Atom()), type_(t) {}
            MatchData(double v) : MatchData(1, MATCH_EQUAL) { data_[0].setFloat(v, true); }
            MatchData(const std::string& s) : MatchData(1, MATCH_EQUAL) { data_[0].setSymbol(gensym(s.c_str()), true); }

            MatchData& operator+=(const MatchData& m) {
                for (auto& a: m.data_) {
                    if(data_.size() < data_.capacity())
                        data_.push_back(a);
                    else {
                        std::cerr << __FUNCTION__ << " [error] to many values: " << data_.size() << std::endl;
                        break;
                    }
                }

                type_ = MATCH_SET;
                return *this;
            }

            size_t size() const { return data_.size(); }
            MatchType type() const { return type_; }
            AtomStaticList::const_iterator begin() const { return data_.cbegin(); }
            AtomStaticList::const_iterator end() const { return data_.cend(); }
            const Atom& at(size_t idx) const {
                static Atom null;
                return (idx >= data_.size()) ? null : data_[idx];
            }

            static MatchData epsilon(double a, double b) {
                MatchData res(2, MATCH_EPSILON);
                res.data_[0].setFloat(a, true);
                res.data_[1].setFloat(b, true);
                return res;
            }

            static MatchData range(double a, double b, MatchType t) {
                MatchData res(2, t);
                res.data_[0].setFloat(a, true);
                res.data_[1].setFloat(b, true);
                return res;
            }

            static MatchData compare(double x, MatchType t) {
                MatchData res(1, t);
                res.data_[0].setFloat(x, true);
                return res;
            }
        };

        void pushMatch(const MatchData& d)
        {
            if(matches_.size() < matches_.capacity())
                matches_.push_back(d);
            else
                std::cerr << __FUNCTION__ << " [error] too many matches: " << matches_.size() << std::endl;
        }

        void pushLexerAtom(const LexerAtom& a)
        {
            atoms_.push_back(a);
        }

        void popLexerAtoms()
        {
            if(atoms_.size() == 1 && atoms_[0].is_float)
                pushMatch(MatchData(std::strtod(atoms_[0].txt.c_str(), nullptr)));
            else {
                std::string res;
                for(auto& a: atoms_)
                    res += a.txt;

                pushMatch(MatchData(res));
            }

            atoms_.clear();
        }

        const MatchData& operator[](size_t idx) const {
            return matches_.at(idx);
        }

        size_t numMatches() const { return matches_.size(); }
        void clearMatches() { matches_.clear(); }
        void mergeMatch() {
            const size_t N = matches_.size();
            if (N < 2)
                return;

            auto& m0 = matches_[N-2];
            const auto& m1 = matches_[N-1];
            m0 += m1;
            matches_.pop_back();
        }

        void setErrorMsg(const std::string& str) { error_msg_ = str; }

    private:
        using MatchList = boost::container::static_vector<MatchData, 128>;
        MatchList matches_;
        std::vector<LexerAtom> atoms_;
        std::string error_msg_;

 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  SelectLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  static const int RANGE = 1;
  static const int EPSILON = 2;
  virtual ceammc::select::SelectParser::symbol_type lex(void);
};

} // namespace ceammc
} // namespace select

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 148 "select.l"
/*%option graphs-file*/
/*%option debug*/
/*%option perf-report*/

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON C++                                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace ceammc {
namespace select {
extern void reflex_code_INITIAL(reflex::Matcher&);
} // namespace ceammc
} // namespace select
namespace ceammc {
namespace select {
extern void reflex_code_RANGE(reflex::Matcher&);
} // namespace ceammc
} // namespace select
namespace ceammc {
namespace select {
extern void reflex_code_EPSILON(reflex::Matcher&);
} // namespace ceammc
} // namespace select

ceammc::select::SelectParser::symbol_type ceammc::select::SelectLexer::lex(void)
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  static const reflex::Pattern PATTERN_RANGE(reflex_code_RANGE);
  static const reflex::Pattern PATTERN_EPSILON(reflex_code_EPSILON);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
    switch (start())
    {
      case INITIAL:
        matcher().pattern(PATTERN_INITIAL);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return ceammc::select::SelectParser::symbol_type(0);
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule select.l:189: {space} :
#line 189 "select.l"
{ return SelectParser::make_SPACE(); }
            break;
          case 2: // rule select.l:190: {epsilon}/{ufloat} :
#line 190 "select.l"
{ return SelectParser::make_EPSILON(); }
            break;
          case 3: // rule select.l:191: {range}/{float} :
#line 191 "select.l"
{ return SelectParser::make_RANGE(); }
            break;
          case 4: // rule select.l:192: {range_clb}/{float} :
#line 192 "select.l"
{ return SelectParser::make_OPEN_BRACKET('['); }
            break;
          case 5: // rule select.l:193: {range_crb} :
#line 193 "select.l"
{ return SelectParser::make_CLOSE_BRACKET(']'); }
            break;
          case 6: // rule select.l:194: {range_olb}/{float} :
#line 194 "select.l"
{ return SelectParser::make_OPEN_PAR('('); }
            break;
          case 7: // rule select.l:195: {range_orb} :
#line 195 "select.l"
{ return SelectParser::make_CLOSE_PAR(')'); }
            break;
          case 8: // rule select.l:196: {or} :
#line 196 "select.l"
{ return SelectParser::make_OR(); }
            break;
          case 9: // rule select.l:197: {ge}/{float} :
#line 197 "select.l"
{ return SelectParser::make_OP_GREATER_EQ(); }
            break;
          case 10: // rule select.l:198: {gt}/{float} :
#line 198 "select.l"
{ return SelectParser::make_OP_GREATER(); }
            break;
          case 11: // rule select.l:199: {lt}/{float} :
#line 199 "select.l"
{ return SelectParser::make_OP_LESS(); }
            break;
          case 12: // rule select.l:200: {le}/{float} :
#line 200 "select.l"
{ return SelectParser::make_OP_LESS_EQ(); }
            break;
          case 13: // rule select.l:201: {float} :
#line 201 "select.l"
{ return SelectParser::make_FLOAT(text()); }
            break;
          case 14: // rule select.l:202: {symbol} :
#line 202 "select.l"
{ return SelectParser::make_SYMBOL(text()); }

            break;
          case 15: // rule select.l:204: . :
#line 204 "select.l"
{   }

            break;
        }
        break;
      case RANGE:
        matcher().pattern(PATTERN_RANGE);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return ceammc::select::SelectParser::symbol_type(0);
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule select.l:204: . :
#line 204 "select.l"
{   }

            break;
        }
        break;
      case EPSILON:
        matcher().pattern(PATTERN_EPSILON);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return ceammc::select::SelectParser::symbol_type(0);
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule select.l:204: . :
#line 204 "select.l"
{   }

            break;
        }
        break;
      default:
        start(0);
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace ceammc {
namespace select {

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S233;
  if (241 <= c1 && c1 <= 243) goto S230;
  if (c1 == 240) goto S227;
  if (238 <= c1 && c1 <= 239) goto S224;
  if (c1 == 237) goto S221;
  if (225 <= c1 && c1 <= 236) goto S218;
  if (c1 == 224) goto S215;
  if (194 <= c1 && c1 <= 223) goto S212;
  if (128 <= c1) goto S175;
  if (c1 == '~') goto S25;
  if (c1 == '|') goto S126;
  if (c1 == ']') goto S77;
  if (c1 == '[') goto S58;
  if (c1 == '>') goto S128;
  if (c1 == '<') goto S148;
  if ('1' <= c1 && c1 <= '9') goto S171;
  if (c1 == '0') goto S168;
  if (c1 == '.') goto S42;
  if (c1 == '-') goto S181;
  if (c1 == '+') goto S181;
  if (c1 == ')') goto S111;
  if (c1 == '(') goto S92;
  if (c1 == ' ') goto S177;
  if ('\t' <= c1 && c1 <= '\n') goto S177;
  if (0 <= c1 && c1 <= 127) goto S197;
  return m.FSM_HALT(c1);

S25:
  m.FSM_TAKE(14);
  m.FSM_HEAD(0);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if ('1' <= c1 && c1 <= '9') goto S240;
  if (c1 == '0') goto S236;
  if ('!' <= c1 && c1 <= '{') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S42:
  m.FSM_TAKE(14);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if (':' <= c1 && c1 <= '{') goto S197;
  if (c1 == '.') goto S261;
  if ('!' <= c1 && c1 <= '/') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S58:
  m.FSM_TAKE(14);
  m.FSM_HEAD(2);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if ('1' <= c1 && c1 <= '9') goto S284;
  if (c1 == '0') goto S280;
  if (c1 == '-') goto S289;
  if (c1 == '+') goto S289;
  if ('!' <= c1 && c1 <= '{') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S77:
  m.FSM_TAKE(5);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if (':' <= c1 && c1 <= '{') goto S197;
  if ('!' <= c1 && c1 <= '/') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S92:
  m.FSM_TAKE(14);
  m.FSM_HEAD(3);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if ('1' <= c1 && c1 <= '9') goto S309;
  if (c1 == '0') goto S305;
  if (c1 == '-') goto S314;
  if (c1 == '+') goto S314;
  if ('!' <= c1 && c1 <= '{') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S111:
  m.FSM_TAKE(7);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if (':' <= c1 && c1 <= '{') goto S197;
  if ('!' <= c1 && c1 <= '/') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S126:
  m.FSM_TAKE(8);
  return m.FSM_HALT();

S128:
  m.FSM_TAKE(14);
  m.FSM_HEAD(5);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if (c1 == '=') goto S330;
  if ('1' <= c1 && c1 <= '9') goto S353;
  if (c1 == '0') goto S349;
  if (c1 == '-') goto S358;
  if (c1 == '+') goto S358;
  if ('!' <= c1 && c1 <= '{') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S148:
  m.FSM_TAKE(14);
  m.FSM_HEAD(6);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if (c1 == '=') goto S383;
  if ('1' <= c1 && c1 <= '9') goto S378;
  if (c1 == '0') goto S374;
  if (c1 == '-') goto S402;
  if (c1 == '+') goto S402;
  if ('!' <= c1 && c1 <= '{') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S168:
  m.FSM_TAKE(13);
  c1 = m.FSM_CHAR();
  if (c1 == '.') goto S418;
  return m.FSM_HALT(c1);

S171:
  m.FSM_TAKE(13);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S171;
  if (c1 == '.') goto S418;
  return m.FSM_HALT(c1);

S175:
  m.FSM_TAKE(15);
  return m.FSM_HALT();

S177:
  m.FSM_TAKE(1);
  c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S177;
  if ('\t' <= c1 && c1 <= '\n') goto S177;
  return m.FSM_HALT(c1);

S181:
  m.FSM_TAKE(14);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if ('1' <= c1 && c1 <= '9') goto S171;
  if (c1 == '0') goto S168;
  if ('!' <= c1 && c1 <= '{') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S197:
  m.FSM_TAKE(14);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if (':' <= c1 && c1 <= '{') goto S197;
  if ('!' <= c1 && c1 <= '/') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S212:
  m.FSM_TAKE(15);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S197;
  return m.FSM_HALT(c1);

S215:
  m.FSM_TAKE(15);
  c1 = m.FSM_CHAR();
  if (160 <= c1 && c1 <= 191) goto S420;
  return m.FSM_HALT(c1);

S218:
  m.FSM_TAKE(15);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S422;
  return m.FSM_HALT(c1);

S221:
  m.FSM_TAKE(15);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 159) goto S424;
  return m.FSM_HALT(c1);

S224:
  m.FSM_TAKE(15);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S426;
  return m.FSM_HALT(c1);

S227:
  m.FSM_TAKE(15);
  c1 = m.FSM_CHAR();
  if (144 <= c1 && c1 <= 191) goto S428;
  return m.FSM_HALT(c1);

S230:
  m.FSM_TAKE(15);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S430;
  return m.FSM_HALT(c1);

S233:
  m.FSM_TAKE(15);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 143) goto S432;
  return m.FSM_HALT(c1);

S236:
  m.FSM_TAKE(2);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if (c1 == '.') goto S434;
  return m.FSM_HALT(c1);

S240:
  m.FSM_TAKE(2);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S240;
  if (c1 == '.') goto S434;
  return m.FSM_HALT(c1);

S245:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S197;
  return m.FSM_HALT(c1);

S247:
  c1 = m.FSM_CHAR();
  if (160 <= c1 && c1 <= 191) goto S420;
  return m.FSM_HALT(c1);

S249:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S422;
  return m.FSM_HALT(c1);

S251:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 159) goto S424;
  return m.FSM_HALT(c1);

S253:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S426;
  return m.FSM_HALT(c1);

S255:
  c1 = m.FSM_CHAR();
  if (144 <= c1 && c1 <= 191) goto S428;
  return m.FSM_HALT(c1);

S257:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S430;
  return m.FSM_HALT(c1);

S259:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 143) goto S432;
  return m.FSM_HALT(c1);

S261:
  m.FSM_TAKE(14);
  m.FSM_HEAD(1);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if ('1' <= c1 && c1 <= '9') goto S440;
  if (c1 == '0') goto S436;
  if (c1 == '-') goto S445;
  if (c1 == '+') goto S445;
  if ('!' <= c1 && c1 <= '{') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S280:
  m.FSM_TAKE(4);
  m.FSM_TAIL(2);
  c1 = m.FSM_CHAR();
  if (c1 == '.') goto S461;
  return m.FSM_HALT(c1);

S284:
  m.FSM_TAKE(4);
  m.FSM_TAIL(2);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S284;
  if (c1 == '.') goto S461;
  return m.FSM_HALT(c1);

S289:
  m.FSM_TAKE(14);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if ('1' <= c1 && c1 <= '9') goto S284;
  if (c1 == '0') goto S280;
  if ('!' <= c1 && c1 <= '{') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S305:
  m.FSM_TAKE(6);
  m.FSM_TAIL(3);
  c1 = m.FSM_CHAR();
  if (c1 == '.') goto S463;
  return m.FSM_HALT(c1);

S309:
  m.FSM_TAKE(6);
  m.FSM_TAIL(3);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S309;
  if (c1 == '.') goto S463;
  return m.FSM_HALT(c1);

S314:
  m.FSM_TAKE(14);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if ('1' <= c1 && c1 <= '9') goto S309;
  if (c1 == '0') goto S305;
  if ('!' <= c1 && c1 <= '{') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S330:
  m.FSM_TAKE(14);
  m.FSM_HEAD(4);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if ('1' <= c1 && c1 <= '9') goto S469;
  if (c1 == '0') goto S465;
  if (c1 == '-') goto S474;
  if (c1 == '+') goto S474;
  if ('!' <= c1 && c1 <= '{') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S349:
  m.FSM_TAKE(10);
  m.FSM_TAIL(5);
  c1 = m.FSM_CHAR();
  if (c1 == '.') goto S490;
  return m.FSM_HALT(c1);

S353:
  m.FSM_TAKE(10);
  m.FSM_TAIL(5);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S353;
  if (c1 == '.') goto S490;
  return m.FSM_HALT(c1);

S358:
  m.FSM_TAKE(14);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if ('1' <= c1 && c1 <= '9') goto S353;
  if (c1 == '0') goto S349;
  if ('!' <= c1 && c1 <= '{') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S374:
  m.FSM_TAKE(11);
  m.FSM_TAIL(6);
  c1 = m.FSM_CHAR();
  if (c1 == '.') goto S492;
  return m.FSM_HALT(c1);

S378:
  m.FSM_TAKE(11);
  m.FSM_TAIL(6);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S378;
  if (c1 == '.') goto S492;
  return m.FSM_HALT(c1);

S383:
  m.FSM_TAKE(14);
  m.FSM_HEAD(7);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if ('1' <= c1 && c1 <= '9') goto S498;
  if (c1 == '0') goto S494;
  if (c1 == '-') goto S503;
  if (c1 == '+') goto S503;
  if ('!' <= c1 && c1 <= '{') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S402:
  m.FSM_TAKE(14);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if ('1' <= c1 && c1 <= '9') goto S378;
  if (c1 == '0') goto S374;
  if ('!' <= c1 && c1 <= '{') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S418:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S519;
  return m.FSM_HALT(c1);

S420:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S197;
  return m.FSM_HALT(c1);

S422:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S197;
  return m.FSM_HALT(c1);

S424:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S197;
  return m.FSM_HALT(c1);

S426:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S197;
  return m.FSM_HALT(c1);

S428:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S522;
  return m.FSM_HALT(c1);

S430:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S524;
  return m.FSM_HALT(c1);

S432:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S526;
  return m.FSM_HALT(c1);

S434:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S528;
  return m.FSM_HALT(c1);

S436:
  m.FSM_TAKE(3);
  m.FSM_TAIL(1);
  c1 = m.FSM_CHAR();
  if (c1 == '.') goto S532;
  return m.FSM_HALT(c1);

S440:
  m.FSM_TAKE(3);
  m.FSM_TAIL(1);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S440;
  if (c1 == '.') goto S532;
  return m.FSM_HALT(c1);

S445:
  m.FSM_TAKE(14);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if ('1' <= c1 && c1 <= '9') goto S440;
  if (c1 == '0') goto S436;
  if ('!' <= c1 && c1 <= '{') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S461:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S534;
  return m.FSM_HALT(c1);

S463:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S538;
  return m.FSM_HALT(c1);

S465:
  m.FSM_TAKE(9);
  m.FSM_TAIL(4);
  c1 = m.FSM_CHAR();
  if (c1 == '.') goto S542;
  return m.FSM_HALT(c1);

S469:
  m.FSM_TAKE(9);
  m.FSM_TAIL(4);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S469;
  if (c1 == '.') goto S542;
  return m.FSM_HALT(c1);

S474:
  m.FSM_TAKE(14);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if ('1' <= c1 && c1 <= '9') goto S469;
  if (c1 == '0') goto S465;
  if ('!' <= c1 && c1 <= '{') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S490:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S544;
  return m.FSM_HALT(c1);

S492:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S548;
  return m.FSM_HALT(c1);

S494:
  m.FSM_TAKE(12);
  m.FSM_TAIL(7);
  c1 = m.FSM_CHAR();
  if (c1 == '.') goto S552;
  return m.FSM_HALT(c1);

S498:
  m.FSM_TAKE(12);
  m.FSM_TAIL(7);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S498;
  if (c1 == '.') goto S552;
  return m.FSM_HALT(c1);

S503:
  m.FSM_TAKE(14);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S259;
  if (241 <= c1 && c1 <= 243) goto S257;
  if (c1 == 240) goto S255;
  if (238 <= c1 && c1 <= 239) goto S253;
  if (c1 == 237) goto S251;
  if (225 <= c1 && c1 <= 236) goto S249;
  if (c1 == 224) goto S247;
  if (194 <= c1 && c1 <= 223) goto S245;
  if ('}' <= c1 && c1 <= 127) goto S197;
  if ('1' <= c1 && c1 <= '9') goto S498;
  if (c1 == '0') goto S494;
  if ('!' <= c1 && c1 <= '{') goto S197;
  if ('\v' <= c1 && c1 <= 31) goto S197;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S197;
  return m.FSM_HALT(c1);

S519:
  m.FSM_TAKE(13);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S519;
  return m.FSM_HALT(c1);

S522:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S197;
  return m.FSM_HALT(c1);

S524:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S197;
  return m.FSM_HALT(c1);

S526:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S197;
  return m.FSM_HALT(c1);

S528:
  m.FSM_TAKE(2);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S528;
  return m.FSM_HALT(c1);

S532:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S554;
  return m.FSM_HALT(c1);

S534:
  m.FSM_TAKE(4);
  m.FSM_TAIL(2);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S534;
  return m.FSM_HALT(c1);

S538:
  m.FSM_TAKE(6);
  m.FSM_TAIL(3);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S538;
  return m.FSM_HALT(c1);

S542:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S558;
  return m.FSM_HALT(c1);

S544:
  m.FSM_TAKE(10);
  m.FSM_TAIL(5);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S544;
  return m.FSM_HALT(c1);

S548:
  m.FSM_TAKE(11);
  m.FSM_TAIL(6);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S548;
  return m.FSM_HALT(c1);

S552:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S562;
  return m.FSM_HALT(c1);

S554:
  m.FSM_TAKE(3);
  m.FSM_TAIL(1);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S554;
  return m.FSM_HALT(c1);

S558:
  m.FSM_TAKE(9);
  m.FSM_TAIL(4);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S558;
  return m.FSM_HALT(c1);

S562:
  m.FSM_TAKE(12);
  m.FSM_TAIL(7);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S562;
  return m.FSM_HALT(c1);
}

} // namespace ceammc

} // namespace select

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace ceammc {
namespace select {

void reflex_code_RANGE(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S3;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S3;
  return m.FSM_HALT(c1);

S3:
  m.FSM_TAKE(1);
  return m.FSM_HALT();
}

} // namespace ceammc

} // namespace select

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace ceammc {
namespace select {

void reflex_code_EPSILON(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S3;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S3;
  return m.FSM_HALT(c1);

S3:
  m.FSM_TAKE(1);
  return m.FSM_HALT();
}

} // namespace ceammc

} // namespace select

