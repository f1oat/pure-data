#!/usr/bin/env python3
import os
import os.path
import sys
import argparse
from termcolor import colored as cl
from jinja2 import Template
import yaml
from pprint import pprint

template_hxx = r'''// this is autogenerated file, do not edit!
#ifndef {{module|upper}}_H_
#define {{module|upper}}_H_
// clang-format off

#include "nui/model.h"
#include "nui/style.h"
#include "m_pd.h"

#include <tuple>

namespace ceammc {
namespace ui {

enum {{module|capitalize}}DataFields {
{% for f in fields %}
    {{module|upper}}_DATA_{{f|upper}},
{% endfor %}
};

class {{module|capitalize}}Data
    : public std::tuple<{{types|join(', ')}}> {
public:
    {{module|capitalize}}Data()
        : std::tuple<{{types|join(', ')}}>({{init|join(', ')}}) { }

    {{module|capitalize}}Data(int style)
        : {{module|capitalize}}Data() {
        setStyle(style);
        loadStyle(style);
    }

{% if use_const %}
    // constants
{% for t, m, v in zip(const_types, const_names, const_values) %}
    static {{t}} {{m}}() noexcept { return {{v}}; }
{% endfor %}
{% endif %}

    // getters
{% for t, m, f in zip(types, getters, fields) %}
    {{t}} {{m}}() const noexcept { return std::get<{{module|upper}}_DATA_{{f|upper}}>(*this); }
{% endfor %}

    // setters
    {% for t, m, f in zip(types, setters, fields) %}
    void set{{m}}({{t}} v) { std::get<{{module|upper}}_DATA_{{f|upper}}>(*this) = v; }
    {% endfor %}

{% if use_style %}
    // style
    void loadStyle(int st) {
        using sc = StyleCollection;
{% for mg, ms, f, i, st in zip(getters, setters, fields, init, styles) %}
{% if st != 'none' %}
        set{{ms}}(sc::{{st}}(st, "{{module|lower}}:{{f}}"_hash, {{i}}));
{% endif %}
{% endfor %}
    }
{% endif %}
};

using {{module|capitalize}}Model = ModelBase<{{module|capitalize}}Data>;

}
}

// clang-format on
#endif
'''

def title(st):
    return ''.join(x for x in st.title() if x.isalnum())

def camelCase(st):
    output = ''.join(x for x in st.title() if x.isalnum())
    return output[0].lower() + output[1:]

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='model generator')
    #    parser.add_argument('-v', '--verbose', help='verbose output', action='store_true')
    #    parser.add_argument('-p', '--pretend', help='just see changes, do not save', action='store_true')
    parser.add_argument('model', metavar='FILE', type=str, help='model name path')
    args = parser.parse_args()
    modelfile = args.model
    if not os.path.exists(modelfile):
        print(cl('[Error!]', 'red'), "file not exists:", modelfile)
        sys.exit(1)

    with open(modelfile) as f:
        mod = yaml.safe_load(f)

    template = Template(template_hxx, trim_blocks=True, lstrip_blocks=True)

    name = mod['name']
    fields = [x['name'].replace(' ', '_') for x in mod['data']]
    getters = [camelCase(x['name']) for x in mod['data']]
    setters = [title(x['name']) for x in mod['data']]
    types = [x['type'] for x in mod['data']]
    init = [x['init'] for x in mod['data']]
    styles = [x.get('style', 'none') for x in mod['data']]
    use_style = styles.count('none') != len(styles)

    consts = mod.get('const', list())
    const_names = [camelCase(x['name']) for x in consts]
    const_types = [x['type'] for x in consts]
    const_values = [x['value'] for x in consts]
    use_const = len(const_names) > 0

    if use_style:
        fields.append('style_idx')
        getters.append('style')
        setters.append('Style')
        types.append('int')
        init.append('0')
        use_style = True
        style_name = name.lower()

    print(template.render(
        module=name,
        fields=fields,
        getters=getters,
        setters=setters,
        types=types,
        init=init,
        use_style=use_style,
        styles=styles,
        use_const=use_const,
        const_names=const_names,
        const_types=const_types,
        const_values=const_values,
        zip=zip,
        camelCase=camelCase))
