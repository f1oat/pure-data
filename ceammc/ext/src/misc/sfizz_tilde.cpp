/*****************************************************************************
 * Copyright 2021 Serge Poltavsky. All rights reserved.
 *
 * This file may be distributed under the terms of GNU Public License version
 * 3 (GPL v3) as defined by the Free Software Foundation (FSF). A copy of the
 * license should have been included with this file, or the project in which
 * this file belongs to. You may also find the details of GPL v3 at:
 * http://www.gnu.org/licenses/gpl-3.0.txt
 *
 * If you have any questions regarding the use of this file, feel free to
 * contact the author of this file, or the owner of the project in which
 * this file belongs to.
 *****************************************************************************/
#include "sfizz_tilde.h"
#include "ceammc_args.h"
#include "ceammc_convert.h"
#include "ceammc_factory.h"
#include "midi/midi_names.h"
#include "proto/proto_midi_cc.h"
#include "proto/proto_midi_cc_rpn_parser.h"

#include <algorithm>
#include <array>
#include <string>

constexpr size_t TUNE_MAX_BANK = 128;
constexpr size_t TUNE_MAX_PRESET = 128;
constexpr const char* PAN_VALUE_NAME = "pan position";
constexpr const char* SCALE_DEFAULT = R"(TET12
12
100.0
200.0
300.0
400.0
500.0
600.0
700.0
800.0
900.0
1000.0
1100.0
1200.0
)";

static std::string make_scale(const std::array<t_float, 12>& scale)
{
    char buf[512] = "autogenerated scale\n12\n";
    char* pbuf = &buf[0] + strlen(buf);

    for (size_t i = 1; i <= scale.size(); i++) {
        const auto f = scale[i % 12] - scale[0];
        pbuf += sprintf(pbuf, "%f\n", (i * 100) + f);
    }

    return buf;
}

static bool is_builtin(const char* name)
{
    static const std::array<std::string, 6> internals = {
        "#sine",
        "#saw",
        "#square",
        "#tri",
        "#noise",
        "#silence",
    };

    if (name[0] != '#')
        return false;

    return std::find(internals.begin(), internals.end(), name) != internals.end();
}

static std::string builtin_sfz(const char* name)
{
    char buf[128] = {};
    snprintf(buf, sizeof(buf) - 1,
        R"(<region>
sample=*%s
ampeg_attack=0.05
ampeg_release=0.1
)",
        name + 1 /*skip initial symbol '#'*/);
    return buf;
}

template <int IN_LEFT, int IN_CENTER, int IN_RIGHT>
uint16_t pan_to_sfizz(t_float v)
{
    constexpr int OUT_LEFT = 0;
    constexpr int OUT_CENTER = 0x2000;
    constexpr int OUT_RIGHT = 0x3fff;

    return (v <= IN_CENTER)
        ? convert::lin2lin<t_float, IN_LEFT, IN_CENTER>(v, OUT_LEFT, OUT_CENTER)
        : convert::lin2lin<t_float, IN_CENTER, IN_RIGHT>(v, OUT_CENTER, OUT_RIGHT);
}

// static member init
SfizzTilde::TuningBank SfizzTilde::tuning_bank_;

SfizzTilde::SfizzTilde(const PdArgs& args)
    : SoundExternal(args)
    , sf_path_(nullptr)
{
    sf_path_ = new SymbolProperty("@sf", &s_);
    addProperty(sf_path_);
    sf_path_->setArgIndex(0);
    sf_path_->setSymbolCheckFn([this](t_symbol* path) -> bool {
        return !findInStdPaths(path->s_name).empty() || is_builtin(path->s_name);
    });
    sf_path_->setSuccessFn([this](Property*) {
        const auto sym_path = sf_path_->value()->s_name;
        if (sym_path[0] == '#') {
            if (!sfz_.loadSfzString(&sym_path[1], builtin_sfz(sym_path))) {
                OBJ_ERR << "can't load virtual soundfont: " << sf_path_->value() << '\n'
                        << builtin_sfz(sym_path);
                return;
            }
        } else {
            auto path = findInStdPaths(sym_path);
            if (!sfz_.loadSfzFile(path)) {
                OBJ_ERR << "can't load soundfont: " << sf_path_->value();
                return;
            }
        }
        updateLabels();
    });

    createCbFloatProperty(
        "@freq",
        [this]() { return sfz_.getTuningFrequency(); },
        [this](t_float f) { sfz_.setTuningFrequency(f); return true; })
        ->setUnits(PropValueUnits::HZ);

    createCbFloatProperty(
        "@volume",
        [this]() { return sfz_.getVolume(); },
        [this](t_float v) { sfz_.setVolume(v); return true; })
        ->setUnits(PropValueUnits::DB);

    createCbFloatProperty(
        "@gain",
        [this]() { return convert::dbfs2amp(sfz_.getVolume()); },
        [this](t_float v) { sfz_.setVolume(convert::amp2dbfs(v)); return true; });

    createCbIntProperty(
        "@poly",
        [this]() { return sfz_.getNumVoices(); },
        [this](int n) { sfz_.setNumVoices(n); return true; });

    createCbIntProperty(
        "@avoices",
        [this]() { return sfz_.getNumActiveVoices(); });

    addProperty(new PointerProperty<Atom>("@key_labels", &key_lables_, PropValueAccess::READONLY));
    addProperty(new PointerProperty<Atom>("@cc_labels", &cc_lables_, PropValueAccess::READONLY));

    createSignalOutlet();
    createSignalOutlet();

    bindMidiParser();
}

void SfizzTilde::setupDSP(t_signal** sig)
{
    SoundExternal::setupDSP(sig);
    sfz_.setSampleRate(samplerate());
    sfz_.setSamplesPerBlock(blockSize());
}

void SfizzTilde::processBlock(const t_sample** in, t_sample** out)
{
    const auto BS = blockSize();

#if PD_FLOATSIZE == 32
    sfz_.renderBlock(out, BS, 1);
#else
    float left[BS];
    float right[BS];
    float* buf[2] = { left, right };
    sfz_.renderBlock(buf, BS, 1);
    for (size_t i = 0; i < BS; i++) {
        out[0][i] = buf[0][i];
        out[1][i] = buf[1][i];
    }
#endif
}

void SfizzTilde::dump() const
{
    SoundExternal::dump();

    {
        Post os(this);
        os << "Key labels:\n";
        for (auto& kv : sfz_.getKeyLabels())
            os << "key: " << (int)kv.first << ", label: " << kv.second << "\n";
    }

    {
        Post os(this);
        os << "CC labels:\n";
        for (auto& kv : sfz_.getCCLabels())
            os << "cc: " << (int)kv.first << ", label: " << kv.second << "\n";
    }
}

void SfizzTilde::m_note(t_symbol* s, const AtomListView& lv)
{
    int key = 0;
    float vel = 0;

    if (lv.size() == 3 && lv[0].isFloat() && lv[1].isFloat() && lv[2].isFloat()) {
        // NOTE: channel is ignored, but leaved for compatibility with fluid~ external
        // that accepts both [note CHAN KEY VEL( and [note KEY VEL( messages
        // int chan = lv[0].asInt();
        key = lv[1].asInt();
        vel = lv[2].asFloat();
    } else if (lv.size() == 2 && lv[0].isFloat() && lv[1].isFloat()) {
        key = lv[0].asInt();
        vel = lv[1].asFloat();
    } else {
        METHOD_ERR(s) << "CHAN? KEY VEL expected, got: " << lv;
        return;
    }

    if (vel > 0)
        sfz_.hdNoteOn(0, key, vel / 127.0);
    else
        sfz_.hdNoteOff(0, key, vel / 127.0);
}

void SfizzTilde::m_cc(t_symbol* s, const AtomListView& lv)
{
    int cc = 0;
    float val = 0;

    if (lv.size() == 3 && lv[0].isFloat() && lv[1].isFloat() && lv[2].isFloat()) {
        // NOTE: channel is ignored, but leaved for compatibility with fluid~ external
        // that accepts both [cc CHAN CC VAL( and [note CC VAL( messages
        // int chan = lv[0].asInt();

        cc = lv[1].asInt();
        val = lv[2].asFloat();
    } else if (lv.size() == 2 && lv[0].isFloat() && lv[1].isFloat()) {
        cc = lv[0].asInt();
        val = lv[1].asFloat();
    } else {
        METHOD_ERR(s) << "CHAN? CC VAL expected, got: " << lv;
        return;
    }

    sfz_.hdcc(0, cc, val / 127.0);
}

void SfizzTilde::m_prog(t_symbol* s, const AtomListView& lv)
{
    int val = 0;

    if (lv.size() == 2 && lv[0].isInteger() && lv[1].isInteger()) {
        // NOTE: channel is ignored, but leaved for compatibility with fluid~ external
        // that accepts both [prog CHAN VAL( and [prog VAL( messages

        val = lv[1].asInt();
    } else if (lv.size() == 1 && lv[0].isInteger()) {
        val = lv[0].asInt();
    } else {
        METHOD_ERR(s) << "CHAN? VAL expected, got: " << lv;
        return;
    }

    sfz_.programChange(0, val);
}

void SfizzTilde::m_midi(t_symbol* s, const AtomListView& lv)
{
    for (auto& byte : lv) {
        if (byte.isFloat()) {
            auto res = midi_parser_.push(byte.asT<int>());
            if (res.err != midi::MidiParser::NO_ERROR)
                METHOD_ERR(s) << res.errStr();
        }
    }
}

void SfizzTilde::m_notesOff(t_symbol* s, const AtomListView& lv)
{
    for (int i = 0; i < 127; i++)
        sfz_.noteOff(0, i, 0);
}

void SfizzTilde::m_bend(t_symbol* s, const AtomListView& lv)
{
    int val = 0;

    if (checkArgs(lv, ARG_FLOAT, ARG_FLOAT))
        val = lv[1].asInt();
    else if (checkArgs(lv, ARG_FLOAT))
        val = lv[0].asInt();
    else {
        METHOD_ERR(s) << "CHAN? VAL expected: " << lv;
        return;
    }

    if (val < 0 || val > 0x3FFF) {
        METHOD_ERR(s) << "value is out of range [0..0x3FFF]: " << val;
        return;
    }

    val -= 0x2000;
    sfz_.pitchWheel(0, val);
}

void SfizzTilde::m_bend_int(t_symbol* s, const AtomListView& lv)
{
    int val = 0;

    if (checkArgs(lv, ARG_FLOAT, ARG_FLOAT))
        val = lv[1].asInt();
    else if (checkArgs(lv, ARG_FLOAT))
        val = lv[0].asInt();
    else {
        METHOD_ERR(s) << "CHAN? VAL expected: " << lv;
        return;
    }

    if (val < -0x2000 || val > 0x1FFF) {
        METHOD_ERR(s) << "value is out of range [-0x2000..0x1FFF]: " << val;
        return;
    }

    sfz_.pitchWheel(0, val);
}

void SfizzTilde::m_bend_float(t_symbol* s, const AtomListView& lv)
{
    float val = 0;

    if (checkArgs(lv, ARG_FLOAT, ARG_FLOAT))
        val = lv[1].asFloat();
    else if (checkArgs(lv, ARG_FLOAT))
        val = lv[0].asFloat();
    else {
        METHOD_ERR(s) << "CHAN? VAL expected: " << lv;
        return;
    }

    if (val < -1 || val > 1) {
        METHOD_ERR(s) << "value is out of range [-1..+1]: " << val;
        return;
    }

    sfz_.hdPitchWheel(0, val);
}

void SfizzTilde::m_set_bend_sens(t_symbol* s, const AtomListView& lv)
{
    METHOD_ERR(s) << "pitch bend sensivity setting is not supported in sfizz library";
}

void SfizzTilde::m_pan(t_symbol* s, const AtomListView& lv)
{
    const auto ch = channelValue<int>(lv);
    if (!ch.ok) {
        METHOD_ERR(s) << "(CHANNEL:i)? PAN:f[0..+0x3fff] expected, got: " << lv;
        return;
    }

    if (!checkChanValue<int>(s, PAN_VALUE_NAME, ch, 0, 0x3fff))
        return;

    setPan(ch.value);
}

void SfizzTilde::m_pan_float(t_symbol* s, const AtomListView& lv)
{
    const auto ch = channelValue<t_float>(lv);
    if (!ch.ok) {
        METHOD_ERR(s) << "(CHANNEL:i)? PAN:f[-1..+1] expected, got: " << lv;
        return;
    }

    if (!checkChanValue<t_float>(s, PAN_VALUE_NAME, ch, -1, 1))
        return;

    setPan(pan_to_sfizz<-1, 0, 1>(ch.value));
}

void SfizzTilde::m_pan_int(t_symbol* s, const AtomListView& lv)
{
    const auto ch = channelValue<int>(lv);
    if (!ch.ok) {
        METHOD_ERR(s) << "(CHANNEL:i)? PAN:f[-8192..+8191] expected, got: " << lv;
        return;
    }

    if (!checkChanValue<int>(s, PAN_VALUE_NAME, ch, -0x2000, 0x1fff))
        return;

    setPan(pan_to_sfizz<-0x2000, 0, 0x1fff>(ch.value));
}

void SfizzTilde::m_hold_pedal(t_symbol* s, const AtomListView& lv)
{
    bool v = false;

    if (checkArgs(lv, ARG_INT, ARG_BOOL))
        v = lv.boolAt(1, false);
    else if (checkArgs(lv, ARG_BOOL))
        v = lv.boolAt(0, false);
    else {
        METHOD_ERR(s) << "1|0 value expected, got: " << lv;
        return;
    }

    sfz_.cc(0, CC_HOLD_PEDAL, v ? 127 : 0);
}

void SfizzTilde::m_sostenuto_pedal(t_symbol* s, const AtomListView& lv)
{
    bool v = false;

    if (checkArgs(lv, ARG_INT, ARG_BOOL))
        v = lv.boolAt(1, false);
    else if (checkArgs(lv, ARG_BOOL))
        v = lv.boolAt(0, false);
    else {
        METHOD_ERR(s) << "1|0 value expected, got: " << lv;
        return;
    }

    sfz_.cc(0, CC_SOSTENUTO_PEDAL, v ? 127 : 0);
}

void SfizzTilde::m_soft_pedal(t_symbol* s, const AtomListView& lv)
{
    bool v = false;

    if (checkArgs(lv, ARG_INT, ARG_BOOL))
        v = lv.boolAt(1, false);
    else if (checkArgs(lv, ARG_BOOL))
        v = lv.boolAt(0, false);
    else {
        METHOD_ERR(s) << "1|0 value expected, got: " << lv;
        return;
    }

    sfz_.cc(0, CC_SOFT_PEDAL, v ? 127 : 0);
}

void SfizzTilde::m_legato_pedal(t_symbol* s, const AtomListView& lv)
{
    bool v = false;

    if (checkArgs(lv, ARG_INT, ARG_BOOL))
        v = lv.boolAt(1, false);
    else if (checkArgs(lv, ARG_BOOL))
        v = lv.boolAt(0, false);
    else {
        METHOD_ERR(s) << "1|0 value expected, got: " << lv;
        return;
    }

    sfz_.cc(0, CC_LEGATO_PEDAL, v ? 127 : 0);
}

void SfizzTilde::m_soundsOff(t_symbol*, const AtomListView&)
{
    sfz_.allSoundOff();
}

void SfizzTilde::m_aftertouch(t_symbol* s, const AtomListView& lv)
{
    float val = 0;

    if (lv.size() == 2 && lv[0].isFloat() && lv[1].isFloat()) {
        // NOTE: channel is ignored, but leaved for compatibility with fluid~ external
        // that accepts both [aftertouch CHAN VAL( and [aftertouch VAL( messages
        // int chan = lv[0].asInt();
        val = lv[1].asFloat();
    } else if (lv.size() == 1 && lv[0].isFloat()) {
        val = lv[0].asFloat();
    } else {
        METHOD_ERR(s) << "CHAN? VAL expected, got: " << lv;
        return;
    }

    sfz_.hdChannelAftertouch(0, val / 127.0);
}

void SfizzTilde::m_polytouch(t_symbol* s, const AtomListView& lv)
{
    int key = 0;
    float vel = 0;

    if (lv.size() == 3 && lv[0].isFloat() && lv[1].isFloat() && lv[2].isFloat()) {
        // NOTE: channel is ignored, but leaved for compatibility with fluid~ external
        // that accepts both [polytouch CHAN KEY VEL( and [polytouch KEY VEL( messages
        // int chan = lv[0].asInt();
        key = lv[1].asInt();
        vel = lv[2].asFloat();
    } else if (lv.size() == 2 && lv[0].isFloat() && lv[1].isFloat()) {
        key = lv[0].asInt();
        vel = lv[1].asFloat();
    } else {
        METHOD_ERR(s) << "CHAN? KEY VEL expected, got: " << lv;
        return;
    }

    sfz_.hdPolyAftertouch(0, key, vel);
}

void SfizzTilde::m_tune_octave(t_symbol* s, const AtomListView& lv)
{
    static ArgChecker chk("i i f f f f f f f f f f f f");

    Error err(this);
    chk.setOut(err);
    if (!chk.check(lv))
        return;

    std::array<t_float, 12> devs;
    for (size_t i = 0; i < 12 && (i + 2) < lv.size(); i++)
        devs[i] = lv[i + 2].asT<t_float>();

    int tune_bank = lv[0].asInt();
    int tune_preset = lv[1].asInt();

    const auto scale = make_scale(devs);
    if (!saveTuning(tune_bank, tune_preset, scale)) {
        METHOD_ERR(s) << "can't save tuning: " << scale;
        return;
    }

    if (!sfz_.loadScalaString(scale)) {
        METHOD_ERR(s) << "can't set tuning: " << scale;
        return;
    } else
        METHOD_DBG(s) << scale;
}

void SfizzTilde::m_tune_select(t_symbol* s, const AtomListView& lv)
{
    if (!checkArgs(lv, ARG_INT, ARG_INT)) {
        METHOD_ERR(s) << "BANK PRESET expected, got: " << lv;
        return;
    }

    int bank = lv.intAt(0, 0);
    int preset = lv.intAt(1, 0);

    if (!selectTuning(bank, preset)) {
        auto ok = sfz_.loadScalaString(SCALE_DEFAULT);

        if (!ok) {
            METHOD_ERR(s) << "can't select tune " << bank << ':' << preset;
            return;
        }
    }
}

void SfizzTilde::updateLabels()
{
    // key labels
    key_lables_->clear();
    char buf[32];
    for (auto& kv : sfz_.getKeyLabels()) {
        snprintf(buf, sizeof(buf) - 1, "%i", static_cast<int>(kv.first));
        key_lables_->insert(buf, gensym(kv.second.c_str()));
    }

    // cc labels
    cc_lables_->clear();
    for (auto& kv : sfz_.getCCLabels()) {
        snprintf(buf, sizeof(buf) - 1, "%i", static_cast<int>(kv.first));
        cc_lables_->insert(buf, gensym(kv.second.c_str()));
    }
}

bool SfizzTilde::saveTuning(size_t bank, size_t preset, const std::string& info)
{
    if (bank >= TUNE_MAX_BANK) {
        LIB_ERR << "invalid bank number: " << bank;
        return false;
    }

    if (preset >= TUNE_MAX_PRESET) {
        LIB_ERR << "invalid preset number: " << preset;
        return false;
    }

    if (bank >= tuning_bank_.size())
        tuning_bank_.resize(bank + 1);

    auto& p = tuning_bank_[bank];
    if (!p)
        p.reset(new TuningPreset(preset));

    if (preset >= p->size())
        p->resize(preset + 1);

    p->at(preset) = info;
    return true;
}

bool SfizzTilde::selectTuning(size_t bank, size_t preset)
{
    if (bank >= TUNE_MAX_BANK) {
        LIB_ERR << "invalid bank number: " << bank;
        return false;
    }

    if (preset >= TUNE_MAX_PRESET) {
        LIB_ERR << "invalid preset number: " << preset;
        return false;
    }

    if (bank >= tuning_bank_.size())
        return false;

    auto& p = tuning_bank_[bank];
    if (!p || preset >= p->size())
        return false;

    return sfz_.loadScalaString(p->at(preset));
}

void SfizzTilde::bindMidiParser()
{
    midi_parser_.setNoteOnFn([this](int /*chan*/, int note, int vel) {
        sfz_.noteOn(0, note, vel);
    });

    midi_parser_.setNoteOffFn([this](int /*chan*/, int note, int vel) {
        sfz_.noteOff(0, note, vel);
    });

    midi_parser_.setControlChangeFn([this](int /*chan*/, int cc, int val) {
        sfz_.cc(0, cc, val);
    });

    midi_parser_.setAfterTouchFn([this](int /*chan*/, int val) {
        sfz_.channelAftertouch(0, val);
    });

    midi_parser_.setPolyTouchFn([this](int, int note, int vel) {
        sfz_.polyAftertouch(0, note, vel);
    });

    midi_parser_.setProgramChangeFn([this](int, int) {
        OBJ_ERR << "program change not suppored";
    });

    midi_parser_.setPitchWheelFn([this](int /*chan*/, int msb, int lsb) {
        int value = ((msb << 7) | lsb) - 0x2000;
        sfz_.pitchWheel(0, value);
    });
}

void SfizzTilde::setPan(uint16_t vuint14)
{
    auto msb = (vuint14 >> 7);
    auto lsb = (vuint14 & 0x7F);
    sfz_.cc(0, CC_PAN_POSITION_COARSE, msb);
    sfz_.cc(0, CC_PAN_POSITION_FINE, lsb);
}

void setup_misc_sfizz_tilde()
{
    SoundExternalFactory<SfizzTilde> obj("sfizz~", OBJECT_FACTORY_DEFAULT);

    obj.addMethod("note", &SfizzTilde::m_note);
    obj.addMethod("cc", &SfizzTilde::m_cc);
    obj.addMethod("prog", &SfizzTilde::m_prog);
    obj.addMethod("midi", &SfizzTilde::m_midi);
    obj.addMethod(M_AFTER_TOUCH, &SfizzTilde::m_aftertouch);
    obj.addMethod(M_POLY_TOUCH, &SfizzTilde::m_polytouch);

    obj.addMethod("bend", &SfizzTilde::m_bend);
    obj.addMethod("bend:i", &SfizzTilde::m_bend_int);
    obj.addMethod("bend:f", &SfizzTilde::m_bend_float);
    obj.addMethod(M_BEND_SENSIVITY, &SfizzTilde::m_set_bend_sens);

    obj.addMethod(M_ALL_NOTES_OFF, &SfizzTilde::m_notesOff);
    obj.addMethod(M_ALL_SOUND_OFF, &SfizzTilde::m_soundsOff);
    obj.addMethod(M_PANIC, &SfizzTilde::m_soundsOff);
    obj.addMethod("reset", &SfizzTilde::m_soundsOff);

    obj.addMethod(M_TUNE_SELECT, &SfizzTilde::m_tune_select);
    obj.addMethod(M_TUNE_OCTAVE, &SfizzTilde::m_tune_octave);

    obj.addMethod("pan", &SfizzTilde::m_pan);
    obj.addMethod(M_PAN_POSITION_FLOAT, &SfizzTilde::m_pan_float);
    obj.addMethod(M_PAN_POSITION_INT, &SfizzTilde::m_pan_int);

    obj.addMethod(M_HOLD_PEDAL, &SfizzTilde::m_hold_pedal);
    obj.addMethod(M_SOSTENUTO_PEDAL, &SfizzTilde::m_sostenuto_pedal);
    obj.addMethod(M_SOFT_PEDAL, &SfizzTilde::m_soft_pedal);
    obj.addMethod("legato", &SfizzTilde::m_legato_pedal);

#ifdef SFIZZ_VERSION
    LIB_DBG << "Sfizz version: " << SFIZZ_VERSION;
#endif
}
