// array_loader.lexer.h generated by reflex 1.6.3 from array_loader.l

#ifndef REFLEX_HEADER_H
#define REFLEX_HEADER_H
#define IN_HEADER 1

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_YYLTYPE             ceammc::location
#define REFLEX_OPTION_YYSTYPE             ceammc::ArrayLoaderParser::semantic_type
#define REFLEX_OPTION_bison_cc            true
#define REFLEX_OPTION_bison_cc_namespace  ceammc
#define REFLEX_OPTION_bison_cc_parser     ArrayLoaderParser
#define REFLEX_OPTION_bison_complete      true
#define REFLEX_OPTION_bison_locations     true
#define REFLEX_OPTION_debug               true
#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_freespace           true
#define REFLEX_OPTION_header_file         "array_loader.lexer.h"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               ArrayLoaderLexer
#define REFLEX_OPTION_namespace           ceammc
#define REFLEX_OPTION_noindent            true
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "array_loader.lexer.cpp"
#define REFLEX_OPTION_reentrant           true
#define REFLEX_OPTION_token_eof           ceammc::ArrayLoaderParser::symbol_type(0, location())
#define REFLEX_OPTION_token_type          ceammc::ArrayLoaderParser::symbol_type
#define REFLEX_OPTION_unicode             true

// --debug option enables ASSERT:
#define ASSERT(c) assert(c)

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top{ user code %}                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "array_loader.l"

    # include <string>
    # include <memory>
    # include <cstdint>
    # include <cmath>

    # include "lex/array_loader.parser.hpp"

    using token = ceammc::ArrayLoaderParser::token;


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define WITH_NO_INDENT
#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace ceammc {

class ArrayLoaderLexer : public reflex::AbstractLexer<reflex::Matcher> {
#line 12 "array_loader.l"

    private:
        std::size_t pat_count_ = {0};
        std::string pat_prefix_;
        std::string pat_suffix_;
        std::vector<std::string> patterns_;
        std::pair<uint, uint> pat_range_ = {0, 0};
        std::vector<uint8_t> channels_;
        bool finished_ = {false};

        size_t output_indent_ = {0};

    public:
        /** return string for output indent */
        inline std::string indent(size_t n = 0, char c = ' ') const {
            return std::string(output_indent_ + n, c);
        }

        /** set debug output indent */
        inline void setOutputIndent(size_t n) { output_indent_ = n; }

 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  ArrayLoaderLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
    set_debug(true);
  }
  static const int INITIAL = 0;
  static const int ARRAY = 1;
  static const int PATTERN = 2;
  static const int RANGE = 3;
  static const int VARIANT = 4;
  static const int OPTIONS = 5;
  static const int SMPTE = 6;
  virtual ceammc::location location(void) const
  {
    ceammc::location yylloc;
    yylloc.begin.line = static_cast<unsigned int>(matcher().lineno());
    yylloc.begin.column = static_cast<unsigned int>(matcher().columno());
    yylloc.end.line = static_cast<unsigned int>(matcher().lineno_end());
    yylloc.end.column = static_cast<unsigned int>(matcher().columno_end());
    return yylloc;
  }
  virtual ceammc::ArrayLoaderParser::symbol_type lex(void);
};

} // namespace ceammc

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON C++                                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#endif
