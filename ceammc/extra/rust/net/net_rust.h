#ifndef ceammc_rust_net_h
#define ceammc_rust_net_h

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdint.h>
#include <stddef.h>
struct ceammc_rs_mqtt_client;
struct ceammc_rs_ws_client;
struct ceammc_rs_ws_server;

enum class ceammc_rs_mqtt_qos {
  /// may lose messages
  AtMostOnce = 0,
  /// guarantees the message delivery but potentially exists duplicate messages
  AtLeastOnce = 1,
  /// ensures that messages are delivered exactly once without duplication
  ExactlyOnce = 2,
};

enum class ceammc_rs_mqtt_rc {
  Ok = 0,
  RefusedProtocolVersion,
  BadClientId,
  ServiceUnavailable,
  BadUserNamePassword,
  NotAuthorized,
  InvalidString,
  InvalidClient,
  ClientError,
  Disconnected,
  NetworkTimeout,
  FlushTimeout,
  ConnectionRefused,
  ConnectionReset,
  ConnectionError,
};

enum class ceammc_rs_ws_rc {
  Ok = 0,
  InvalidClient,
  InvalidServer,
  InvalidMessage,
  SendError,
  NoData,
  CloseError,
  ConnectionClosed,
  NonBlockingError,
  SocketAcceptError,
  SocketReadError,
  SocketDeferClose,
};

struct ceammc_rs_ws_callback_text {
  void *user;
  void (*cb)(void *user, const char *msg);
};

struct ceammc_rs_ws_callback_data {
  void *user;
  void (*cb)(void *user, const uint8_t *data, size_t len);
};


extern "C" {

/// create new mqtt client
/// @param host - mqtt broker hostname
/// @param port - mqtt broker port
/// @param id - client id
/// @param user - mqtt username (can be NULL)
/// @param pass - mqtt password (can be NULL)
/// @return pointer to mqtt_client (must be freed by ceammc_rs_mqtt_client_free()) on success
///         or NULL on error
ceammc_rs_mqtt_client *ceammc_rs_mqtt_client_create(const char *host,
                                                    uint16_t port,
                                                    const char *id,
                                                    const char *user,
                                                    const char *password);

/// free mqtt client
/// @param cli - mqtt client
void ceammc_rs_mqtt_client_free(ceammc_rs_mqtt_client *cli);

/// publish text message into mqtt topic
/// @param topic - mqtt topic ('+' single layer wildcard, '#' recursive layer wildcard)
/// @param msg - mqtt message
/// @param qos - Quality of Service flag
/// @param retain - This flag tells the broker to store the message for a topic
///        and ensures any new client subscribing to that topic will receive the stored message.
/// @return ceammc_rs_mqtt_rc::Ok on success
ceammc_rs_mqtt_rc ceammc_rs_mqtt_client_publish(ceammc_rs_mqtt_client *cli,
                                                const char *topic,
                                                const char *msg,
                                                ceammc_rs_mqtt_qos qos,
                                                bool retain);

/// publish binary data into mqtt topic
/// @param topic - mqtt topic ('+' single layer wildcard, '#' recursive layer wildcard)
/// @param data - mqtt binary data
/// @param len - mqtt binary data length
/// @param qos - Quality of Service flag
/// @param retain - This flag tells the broker to store the message for a topic
///        and ensures any new client subscribing to that topic will receive the stored message
/// @return ceammc_rs_mqtt_rc::Ok on success
ceammc_rs_mqtt_rc ceammc_rs_mqtt_client_publish_data(ceammc_rs_mqtt_client *cli,
                                                     const char *topic,
                                                     const uint8_t *data,
                                                     size_t len,
                                                     ceammc_rs_mqtt_qos qos,
                                                     bool retain);

/// subscribe to mqtt topic
/// @param cli - mqtt client
/// @param topic - mqtt topic
/// @return ceammc_rs_mqtt_rc::Ok on success
ceammc_rs_mqtt_rc ceammc_rs_mqtt_client_subscribe(ceammc_rs_mqtt_client *cli, const char *topic);

/// unsubscribe from mqtt topic
/// @param cli - mqtt client
/// @param topic - mqtt topic
/// @return ceammc_rs_mqtt_rc::Ok on success
ceammc_rs_mqtt_rc ceammc_rs_mqtt_client_unsubscribe(ceammc_rs_mqtt_client *cli, const char *topic);

/// iterate mqtt events
/// @param cli - mqtt client pointer
/// @param time_ms - time to blocking wait in milliseconds
/// @param cb_data - pointer to user data for callbacks
/// @param cb_ping - ping callback (user data)
/// @param cb_pub - publish callback (user data, topic, message data, message size)
/// @param cb_conn - connection callback (user_data, result code)
/// @return ceammc_rs_mqtt_rc::Ok on success
ceammc_rs_mqtt_rc ceammc_rs_mqtt_runloop(ceammc_rs_mqtt_client *cli,
                                         uint16_t time_ms,
                                         void *cb_data,
                                         void (*cb_ping)(void*),
                                         void (*cb_pub)(void*, const char*, const uint8_t*, size_t),
                                         void (*cb_conn)(void*, ceammc_rs_mqtt_rc code));

ceammc_rs_ws_rc ceammc_rs_ws_client_close(ceammc_rs_ws_client *cli);

ceammc_rs_ws_client *ceammc_rs_ws_client_create(const char *url,
                                                ceammc_rs_ws_callback_text on_err,
                                                ceammc_rs_ws_callback_text on_text,
                                                ceammc_rs_ws_callback_data on_bin,
                                                ceammc_rs_ws_callback_data on_ping,
                                                ceammc_rs_ws_callback_data on_pong);

void ceammc_rs_ws_client_free(ceammc_rs_ws_client *cli);

ceammc_rs_ws_rc ceammc_rs_ws_client_read(ceammc_rs_ws_client *cli);

ceammc_rs_ws_rc ceammc_rs_ws_client_send_ping(ceammc_rs_ws_client *cli, bool flush);

ceammc_rs_ws_rc ceammc_rs_ws_client_send_pong(ceammc_rs_ws_client *cli, bool flush);

/// sends text message to WebSocket server
/// @param cli - pointer to ws client
/// @param msg - text message
/// @param flush - if true ensures all messages
///        previously passed to write and automatic queued pong responses are written & flushed into the underlying stream.
/// @return ws_rc::Ok, ws_rc::InvalidClient, ws_rc::InvalidMessage, ws_rc::CloseError, ws_rc::SendError,
ceammc_rs_ws_rc ceammc_rs_ws_client_send_text(ceammc_rs_ws_client *cli,
                                              const char *msg,
                                              bool flush);

ceammc_rs_ws_server *ceammc_rs_ws_server_create(const char *addr,
                                                ceammc_rs_ws_callback_text on_err);

void ceammc_rs_ws_server_free(ceammc_rs_ws_server *srv);

ceammc_rs_ws_rc ceammc_rs_ws_server_runloop(ceammc_rs_ws_server *srv);

} // extern "C"

#endif // ceammc_rust_net_h
