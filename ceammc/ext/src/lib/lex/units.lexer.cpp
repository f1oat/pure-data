// units.lexer.cpp generated by reflex 3.0.1 from units.l

#define REFLEX_VERSION "3.0.1"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_freespace           true
#define REFLEX_OPTION_header_file         "units.lexer.h"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               UnitsLexer
#define REFLEX_OPTION_namespace           ceammc::units
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "units.lexer.cpp"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "units.l"

    # include <cerrno>
    # include <cstdlib>
    # include <cstdint>
    # include <cmath>
    # include <array>

    # include "ceammc_log.h"


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace ceammc {
namespace units {

class UnitsLexer : public reflex::AbstractLexer<reflex::Matcher> {
#line 11 "units.l"

    public:
        enum UnitType : uint8_t {
            U_UNKNOWN,
            U_MSEC,
            U_SEC,
            U_MINUTE,
            U_HOUR,
            U_DAY,
            U_SAMP,
            U_HZ,
            U_CENT,
            U_SEMITONE,
            U_TONE,
            U_BPM,
            U_RADIANS,
            U_DEGREE,
            U_DB,
            U_SMPTE,
            U_PERCENT,
            U_RATIO,
            U_PHASE
        };

        enum ValueType : uint8_t {
            T_DOUBLE, T_LONG, T_SMPTE, T_RATIO
        };

        enum Status {
            STATUS_UNKNOWN_TOKEN = -2,
            STATUS_PARSE_ERROR = -1,
            STATUS_EOF = 0,
            STATUS_OK = 1,
            STATUS_CONTINUE
        };

        struct Smpte {
            uint8_t hour;
            uint8_t min;
            uint8_t sec;
            uint8_t frame;

            double toSeconds(double framerate) const {
                return 3600 * hour + 60 * min + sec + (frame / framerate);
            }
        };

        struct Ratio {
            int32_t num;
            int32_t den;
        };

        union Value {
            long int_val;
            double dbl_val;
            Ratio ratio_val;
            Smpte smpte_val;
        };

        struct UnitValue {
            Value val;
            ValueType type;
            UnitType unit = {U_UNKNOWN};
            bool end_offset = {false};
        };

        static constexpr size_t MAX_UNITS = 8;

        struct UnitValues {
            std::array<UnitValue, MAX_UNITS> data;
            size_t n = {1};

            UnitValue& back() { return data[n-1]; }
            void append() { if(n < MAX_UNITS-1) data[n++].val.int_val = 0; }
            void set(double v, UnitType u) { back().val.dbl_val = v; back().unit = u; back().type = T_DOUBLE; }
            void set(long v, UnitType u) { back().val.int_val = v; back().unit = u; back().type = T_LONG; }
            void set(const Smpte& v) { back().val.smpte_val = v; back().unit = U_SMPTE; back().type = T_SMPTE; }
            void set(const Ratio& v) { back().val.ratio_val = v; back().unit = U_RATIO; back().type = T_RATIO; }

            UnitValue& operator[](size_t i) { return data[i]; }
        };

    public:
        UnitValues values;

        int parseSingle()
        {
            values.n = 1;
            int rc = STATUS_OK;
            for(rc = STATUS_OK; rc == STATUS_OK || rc == STATUS_CONTINUE; rc = lex()) {
                if(rc == STATUS_CONTINUE) {
                    // lookup next
                    if (lex() != STATUS_OK) // invalid next token
                       return STATUS_UNKNOWN_TOKEN;

                    // next token is valid, but we are parsing just one
                    values.n = 1;
                    return STATUS_EOF;
                }
            }

            return rc;
        }

        int parseMany()
        {
            values.n = 1;
            int rc;
            for(rc = STATUS_OK; rc == STATUS_OK || rc == STATUS_CONTINUE; rc = lex())
            ;

            return rc;
        }

 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  UnitsLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  virtual int lex(void);
  int lex(const reflex::Input& input)
  {
    in(input);
    return lex();
  }
  int lex(const reflex::Input& input, std::ostream *os)
  {
    in(input);
    if (os)
      out(*os);
    return lex();
  }
};

} // namespace ceammc
} // namespace units

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 132 "units.l"
/*%option debug*/

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace ceammc {
namespace units {
extern void reflex_code_INITIAL(reflex::Matcher&);
} // namespace ceammc
} // namespace units

int ceammc::units::UnitsLexer::lex(void)
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
#line 304 "units.l"
{   return STATUS_EOF;  }
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule units.l:171: {space} :
#line 171 "units.l"
{   values.append(); return STATUS_CONTINUE; }
            break;
          case 2: // rule units.l:172: {percent} :
#line 172 "units.l"
{
                    auto v = strtod(text(), nullptr);
                    values.set(v, U_PERCENT);
                    return STATUS_OK;
                }
            break;
          case 3: // rule units.l:177: {phase} :
#line 177 "units.l"
{
                    auto v = strtod(text(), nullptr);
                    values.set(v, U_PHASE);
                    return STATUS_OK;
                }
            break;
          case 4: // rule units.l:182: {ratio} :
#line 182 "units.l"
{
                    errno = 0;
                    char* endptr = nullptr;
                    const int32_t n = strtol(text(), &endptr, 10);
                    const int32_t d = strtol(endptr+1, nullptr, 10);

                    if (errno)
                        return STATUS_PARSE_ERROR;

                    if (d == 0) {
                        LIB_ERR << "[units] division by zero: " << text();
                        return STATUS_PARSE_ERROR;
                    }

                    values.set(Ratio{n, d});
                    return STATUS_OK;
                }
            break;
          case 5: // rule units.l:199: {msec} :
#line 199 "units.l"
{
                    const double v = strtod(text(), nullptr);
                    if(!std::isnormal(v) && v != 0)
                        return STATUS_PARSE_ERROR;

                    values.set(v, U_MSEC);
                    return STATUS_OK;
                }
            break;
          case 6: // rule units.l:207: {int} :
#line 207 "units.l"
{
                    errno = 0;
                    auto v = strtol(text(), nullptr, 10);
                    if (errno)
                        return STATUS_PARSE_ERROR;

                    values.set(v, U_MSEC);
                    return STATUS_OK;
                }
            break;
          case 7: // rule units.l:216: {samp} :
#line 216 "units.l"
{
                    errno = 0;
                    auto v = strtol(text(), nullptr, 10);
                    if (errno)
                        return STATUS_PARSE_ERROR;
                    values.set(v, U_SAMP);
                    return STATUS_OK;
                }
            break;
          case 8: // rule units.l:224: {sec} :
#line 224 "units.l"
{
                    auto v = strtod(text(), nullptr);
                    if(!std::isnormal(v) && v != 0)
                        return STATUS_PARSE_ERROR;

                    values.set(v, U_SEC);
                    return STATUS_OK;
                }
            break;
          case 9: // rule units.l:232: {min} :
#line 232 "units.l"
{
                    auto v = strtod(text(), nullptr);
                    if(!std::isnormal(v) && v != 0)
                        return STATUS_PARSE_ERROR;

                    values.set(v, U_MINUTE);
                    return STATUS_OK;
                }
            break;
          case 10: // rule units.l:240: {hz} :
#line 240 "units.l"
{
                    auto v = strtod(text(), nullptr);
                    values.set(v, U_HZ);
                    return STATUS_OK;
                }
            break;
          case 11: // rule units.l:245: {hour} :
#line 245 "units.l"
{
                    auto v = strtod(text(), nullptr);
                    values.set(v, U_HOUR);
                    return STATUS_OK;
                }
            break;
          case 12: // rule units.l:250: {day} :
#line 250 "units.l"
{
                    auto v = strtod(text(), nullptr);
                    values.set(v, U_DAY);
                    return STATUS_OK;
                }
            break;
          case 13: // rule units.l:255: {bpm} :
#line 255 "units.l"
{
                    char* end = 0;
                    auto v = strtod(text(), &end);
                    if(!std::isnormal(v) && v != 0)
                        return STATUS_PARSE_ERROR;

                    int subdiv = 1;
                    if(end && end[0] == '#')
                        subdiv = strtol(end+1, nullptr, 10);

                    values.set(v * subdiv, U_BPM);
                    return STATUS_OK;
                }
            break;
          case 14: // rule units.l:268: {smpte} :
#line 268 "units.l"
{
                    uint8_t d0 = 0; // hour
                    uint8_t d1 = 0; // min
                    uint8_t d2 = 0; // sec
                    uint8_t d3 = 0; // frame
                    char* end = 0;
                    const char* txt = text();
                    d0 = strtol(txt, &end, 10);
                    if (*end == ':') { // 00:
                        d1 = strtol(txt+3, &end, 10);
                        if (*end == ':') { // 00:00:
                            d2 = strtol(txt+6, &end, 10);
                            if (*end == '.') // 00:00:00.
                                d3 = strtol(txt+9, nullptr, 10);
                        } else if(*end == '.') { // 00:00.
                            d3 = strtol(txt+6, nullptr, 10);
                            d2 = d1;
                            d1 = d0;
                            d0 = 0;
                        } else { // 00:00
                            d2 = d1;
                            d1 = d0;
                            d0 = 0;
                        }
                    } else {
                        std::cerr << text() << "\n";
                        return STATUS_PARSE_ERROR;
                        }

                    values.set(Smpte{d0, d1, d2, d3});
                    return STATUS_OK;
                }
            break;
          case 15: // rule units.l:300: {end_offset} :
#line 300 "units.l"
{
                    values.back().end_offset = true;
                    return STATUS_OK;
                }
            break;
          case 16: // rule units.l:305: . :
#line 305 "units.l"
{   return STATUS_UNKNOWN_TOKEN; }

            break;
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 308 "units.l"


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace ceammc {
namespace units {

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S41;
  if ('1' <= c1 && c1 <= '9') goto S23;
  if (c1 == '0') goto S9;
  if (c1 == '-') goto S50;
  if (c1 == '+') goto S50;
  if (c1 == '$') goto S37;
  if (c1 == ' ') goto S46;
  if ('\t' <= c1 && c1 <= '\n') goto S46;
  if (0 <= c1) goto S44;
  return m.FSM_HALT(c1);

S9:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S64;
  if (c1 == 'm') goto S61;
  if (c1 == 'h') goto S68;
  if (c1 == 'd') goto S71;
  if (c1 == 'b') goto S73;
  if (c1 == '_') goto S79;
  if ('0' <= c1 && c1 <= '9') goto S75;
  if (c1 == '/') goto S58;
  if (c1 == '.') goto S77;
  if (c1 == '*') goto S56;
  if (c1 == '%') goto S54;
  if (c1 == '#') goto S87;
  return m.FSM_HALT(c1);

S23:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S64;
  if (c1 == 'm') goto S61;
  if (c1 == 'h') goto S68;
  if (c1 == 'd') goto S71;
  if (c1 == 'b') goto S73;
  if (c1 == '_') goto S79;
  if ('0' <= c1 && c1 <= '9') goto S94;
  if (c1 == '/') goto S58;
  if (c1 == '.') goto S77;
  if (c1 == '*') goto S56;
  if (c1 == '%') goto S54;
  if (c1 == '#') goto S87;
  return m.FSM_HALT(c1);

S37:
  m.FSM_TAKE(16);
  m.FSM_HEAD(0);
  c1 = m.FSM_CHAR();
  if (c1 == '-') goto S109;
  return m.FSM_HALT(c1);

S41:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S112;
  return m.FSM_HALT(c1);

S44:
  m.FSM_TAKE(16);
  return m.FSM_HALT();

S46:
  m.FSM_TAKE(1);
  c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S46;
  if ('\t' <= c1 && c1 <= '\n') goto S46;
  return m.FSM_HALT(c1);

S50:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if ('1' <= c1 && c1 <= '9') goto S126;
  if (c1 == '0') goto S114;
  return m.FSM_HALT(c1);

S54:
  m.FSM_TAKE(2);
  return m.FSM_HALT();

S56:
  m.FSM_TAKE(3);
  return m.FSM_HALT();

S58:
  c1 = m.FSM_CHAR();
  if ('1' <= c1 && c1 <= '9') goto S141;
  if (c1 == '0') goto S139;
  return m.FSM_HALT(c1);

S61:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S144;
  if (c1 == 'i') goto S147;
  return m.FSM_HALT(c1);

S64:
  m.FSM_TAKE(8);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S152;
  if (c1 == 'a') goto S149;
  return m.FSM_HALT(c1);

S68:
  m.FSM_TAKE(11);
  c1 = m.FSM_CHAR();
  if (c1 == 'z') goto S154;
  return m.FSM_HALT(c1);

S71:
  m.FSM_TAKE(12);
  return m.FSM_HALT();

S73:
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S156;
  return m.FSM_HALT(c1);

S75:
  c1 = m.FSM_CHAR();
  if (c1 == ':') goto S158;
  return m.FSM_HALT(c1);

S77:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S160;
  return m.FSM_HALT(c1);

S79:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S64;
  if (c1 == 'm') goto S61;
  if (c1 == 'h') goto S68;
  if (c1 == 'd') goto S71;
  if (c1 == 'b') goto S73;
  if (c1 == '*') goto S56;
  if (c1 == '%') goto S54;
  return m.FSM_HALT(c1);

S87:
  c1 = m.FSM_CHAR();
  if (c1 == '8') goto S171;
  if (c1 == '6') goto S181;
  if (c1 == '4') goto S171;
  if (c1 == '3') goto S179;
  if (c1 == '2') goto S183;
  if (c1 == '1') goto S174;
  return m.FSM_HALT(c1);

S94:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S64;
  if (c1 == 'm') goto S61;
  if (c1 == 'h') goto S68;
  if (c1 == 'd') goto S71;
  if (c1 == 'b') goto S73;
  if (c1 == '_') goto S79;
  if (c1 == ':') goto S158;
  if ('0' <= c1 && c1 <= '9') goto S187;
  if (c1 == '/') goto S58;
  if (c1 == '.') goto S77;
  if (c1 == '*') goto S56;
  if (c1 == '%') goto S54;
  if (c1 == '#') goto S87;
  return m.FSM_HALT(c1);

S109:
  c1 = m.FSM_CHAR();
  if ('1' <= c1 && c1 <= '9') goto S208;
  if (c1 == '0') goto S201;
  return m.FSM_HALT(c1);

S112:
  c1 = m.FSM_CHAR();
  if (c1 == 'd') goto S216;
  return m.FSM_HALT(c1);

S114:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S64;
  if (c1 == 'm') goto S61;
  if (c1 == 'h') goto S68;
  if (c1 == 'd') goto S71;
  if (c1 == 'b') goto S73;
  if (c1 == '_') goto S79;
  if (c1 == '.') goto S77;
  if (c1 == '*') goto S56;
  if (c1 == '%') goto S54;
  if (c1 == '#') goto S87;
  return m.FSM_HALT(c1);

S126:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S64;
  if (c1 == 'm') goto S61;
  if (c1 == 'h') goto S68;
  if (c1 == 'd') goto S71;
  if (c1 == 'b') goto S73;
  if (c1 == '_') goto S79;
  if ('0' <= c1 && c1 <= '9') goto S126;
  if (c1 == '.') goto S77;
  if (c1 == '*') goto S56;
  if (c1 == '%') goto S54;
  if (c1 == '#') goto S87;
  return m.FSM_HALT(c1);

S139:
  m.FSM_TAKE(4);
  return m.FSM_HALT();

S141:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S141;
  return m.FSM_HALT(c1);

S144:
  m.FSM_TAKE(5);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S219;
  return m.FSM_HALT(c1);

S147:
  c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S221;
  return m.FSM_HALT(c1);

S149:
  m.FSM_TAKE(7);
  c1 = m.FSM_CHAR();
  if (c1 == 'm') goto S223;
  return m.FSM_HALT(c1);

S152:
  c1 = m.FSM_CHAR();
  if (c1 == 'c') goto S225;
  return m.FSM_HALT(c1);

S154:
  m.FSM_TAKE(10);
  return m.FSM_HALT();

S156:
  c1 = m.FSM_CHAR();
  if (c1 == 'm') goto S227;
  return m.FSM_HALT(c1);

S158:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S229;
  return m.FSM_HALT(c1);

S160:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S231;
  if (c1 == 'm') goto S61;
  if (c1 == 'h') goto S68;
  if (c1 == 'd') goto S71;
  if (c1 == 'b') goto S73;
  if (c1 == '_') goto S234;
  if ('0' <= c1 && c1 <= '9') goto S160;
  if (c1 == '*') goto S56;
  if (c1 == '%') goto S54;
  if (c1 == '#') goto S87;
  return m.FSM_HALT(c1);

S171:
  c1 = m.FSM_CHAR();
  if (c1 == 'b') goto S73;
  if (c1 == '_') goto S242;
  return m.FSM_HALT(c1);

S174:
  c1 = m.FSM_CHAR();
  if (c1 == 'b') goto S73;
  if (c1 == '_') goto S242;
  if (c1 == '6') goto S171;
  if (c1 == '2') goto S244;
  return m.FSM_HALT(c1);

S179:
  c1 = m.FSM_CHAR();
  if (c1 == '2') goto S171;
  return m.FSM_HALT(c1);

S181:
  c1 = m.FSM_CHAR();
  if (c1 == '4') goto S171;
  return m.FSM_HALT(c1);

S183:
  c1 = m.FSM_CHAR();
  if (c1 == 'b') goto S73;
  if (c1 == '_') goto S242;
  if (c1 == '5') goto S246;
  return m.FSM_HALT(c1);

S187:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S64;
  if (c1 == 'm') goto S61;
  if (c1 == 'h') goto S68;
  if (c1 == 'd') goto S71;
  if (c1 == 'b') goto S73;
  if (c1 == '_') goto S79;
  if ('0' <= c1 && c1 <= '9') goto S187;
  if (c1 == '/') goto S58;
  if (c1 == '.') goto S77;
  if (c1 == '*') goto S56;
  if (c1 == '%') goto S54;
  if (c1 == '#') goto S87;
  return m.FSM_HALT(c1);

S201:
  m.FSM_TAKE(15);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S248;
  if (c1 == 'm') goto S253;
  if (c1 == '_') goto S256;
  if (c1 == '.') goto S259;
  return m.FSM_HALT(c1);

S208:
  m.FSM_TAKE(15);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S248;
  if (c1 == 'm') goto S253;
  if (c1 == '_') goto S256;
  if ('0' <= c1 && c1 <= '9') goto S208;
  if (c1 == '.') goto S259;
  return m.FSM_HALT(c1);

S216:
  m.FSM_HEAD(0);
  c1 = m.FSM_CHAR();
  if (c1 == '-') goto S109;
  return m.FSM_HALT(c1);

S219:
  c1 = m.FSM_CHAR();
  if (c1 == 'c') goto S261;
  return m.FSM_HALT(c1);

S221:
  m.FSM_TAKE(9);
  return m.FSM_HALT();

S223:
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S263;
  return m.FSM_HALT(c1);

S225:
  m.FSM_TAKE(8);
  return m.FSM_HALT();

S227:
  m.FSM_TAKE(13);
  return m.FSM_HALT();

S229:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S265;
  return m.FSM_HALT(c1);

S231:
  m.FSM_TAKE(8);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S152;
  return m.FSM_HALT(c1);

S234:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S231;
  if (c1 == 'm') goto S61;
  if (c1 == 'h') goto S68;
  if (c1 == 'd') goto S71;
  if (c1 == 'b') goto S73;
  if (c1 == '*') goto S56;
  if (c1 == '%') goto S54;
  return m.FSM_HALT(c1);

S242:
  c1 = m.FSM_CHAR();
  if (c1 == 'b') goto S73;
  return m.FSM_HALT(c1);

S244:
  c1 = m.FSM_CHAR();
  if (c1 == '8') goto S171;
  return m.FSM_HALT(c1);

S246:
  c1 = m.FSM_CHAR();
  if (c1 == '6') goto S171;
  return m.FSM_HALT(c1);

S248:
  m.FSM_TAKE(15);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S274;
  if (c1 == 'a') goto S270;
  return m.FSM_HALT(c1);

S253:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S276;
  if (c1 == 'i') goto S280;
  return m.FSM_HALT(c1);

S256:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S248;
  if (c1 == 'm') goto S253;
  return m.FSM_HALT(c1);

S259:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S282;
  return m.FSM_HALT(c1);

S261:
  m.FSM_TAKE(5);
  return m.FSM_HALT();

S263:
  m.FSM_TAKE(7);
  return m.FSM_HALT();

S265:
  m.FSM_TAKE(14);
  c1 = m.FSM_CHAR();
  if (c1 == ':') goto S287;
  if ('\v' <= c1) goto S289;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S289;
  return m.FSM_HALT(c1);

S270:
  m.FSM_TAKE(15);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if (c1 == 'm') goto S291;
  return m.FSM_HALT(c1);

S274:
  c1 = m.FSM_CHAR();
  if (c1 == 'c') goto S293;
  return m.FSM_HALT(c1);

S276:
  m.FSM_TAKE(15);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S296;
  return m.FSM_HALT(c1);

S280:
  c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S293;
  return m.FSM_HALT(c1);

S282:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S298;
  if (c1 == 'm') goto S253;
  if (c1 == '_') goto S302;
  if ('0' <= c1 && c1 <= '9') goto S282;
  return m.FSM_HALT(c1);

S287:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S305;
  return m.FSM_HALT(c1);

S289:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S307;
  return m.FSM_HALT(c1);

S291:
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S293;
  return m.FSM_HALT(c1);

S293:
  m.FSM_TAKE(15);
  m.FSM_TAIL(0);
  return m.FSM_HALT();

S296:
  c1 = m.FSM_CHAR();
  if (c1 == 'c') goto S293;
  return m.FSM_HALT(c1);

S298:
  m.FSM_TAKE(15);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S274;
  return m.FSM_HALT(c1);

S302:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S298;
  if (c1 == 'm') goto S253;
  return m.FSM_HALT(c1);

S305:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S309;
  return m.FSM_HALT(c1);

S307:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S313;
  return m.FSM_HALT(c1);

S309:
  m.FSM_TAKE(14);
  c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S289;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S289;
  return m.FSM_HALT(c1);

S313:
  m.FSM_TAKE(14);
  return m.FSM_HALT();
}

} // namespace ceammc

} // namespace units

