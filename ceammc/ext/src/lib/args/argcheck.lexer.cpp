// argcheck.lexer.cpp generated by reflex 2.1.5 from argcheck.l

#define REFLEX_VERSION "2.1.5"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_YYLTYPE             ceammc::argcheck::location
#define REFLEX_OPTION_YYSTYPE             ceammc::argcheck::ArgCheckParser::semantic_type
#define REFLEX_OPTION_bison_cc            true
#define REFLEX_OPTION_bison_cc_namespace  ceammc::argcheck
#define REFLEX_OPTION_bison_cc_parser     ArgCheckParser
#define REFLEX_OPTION_bison_complete      true
#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_freespace           true
#define REFLEX_OPTION_header_file         "argcheck.lexer.h"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               ArgCheckLexer
#define REFLEX_OPTION_namespace           ceammc::argcheck
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "argcheck.lexer.cpp"
#define REFLEX_OPTION_reentrant           true
#define REFLEX_OPTION_token_eof           ceammc::argcheck::ArgCheckParser::symbol_type(0)
#define REFLEX_OPTION_token_type          ceammc::argcheck::ArgCheckParser::symbol_type
#define REFLEX_OPTION_unicode             true

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "argcheck.l"

    # include <string>
    # include <memory>

    # include "argcheck.parser.hpp"
    using token = ceammc::argcheck::ArgCheckParser::token;


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace ceammc {
namespace argcheck {

class ArgCheckLexer : public reflex::AbstractLexer<reflex::Matcher> {
 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  ArgCheckLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  virtual ceammc::argcheck::ArgCheckParser::symbol_type lex(void);
};

} // namespace ceammc
} // namespace argcheck

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 14 "argcheck.l"
/*%option graphs-file*/
/*%option debug*/

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON C++                                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace ceammc {
namespace argcheck {
extern void reflex_code_INITIAL(reflex::Matcher&);
} // namespace ceammc
} // namespace argcheck

ceammc::argcheck::ArgCheckParser::symbol_type ceammc::argcheck::ArgCheckLexer::lex(void)
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return ceammc::argcheck::ArgCheckParser::symbol_type(0);
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule argcheck.l:46: a :
#line 46 "argcheck.l"
{ return token::TATOM; }
            break;
          case 2: // rule argcheck.l:47: b :
#line 47 "argcheck.l"
{ return token::TBOOL; }
            break;
          case 3: // rule argcheck.l:48: d :
#line 48 "argcheck.l"
{ return token::TDATA; }
            break;
          case 4: // rule argcheck.l:49: f :
#line 49 "argcheck.l"
{ return token::TFLOAT; }
            break;
          case 5: // rule argcheck.l:50: f/{float_range} :
#line 50 "argcheck.l"
{ return token::TFLOAT; } // to prevent {symbol} longest match in f2..4 case
            break;
          case 6: // rule argcheck.l:51: s :
#line 51 "argcheck.l"
{ return token::TSYMBOL; }
            break;
          case 7: // rule argcheck.l:52: i :
#line 52 "argcheck.l"
{ return token::TINT; } // for simple i types
            break;
          case 8: // rule argcheck.l:53: i/{int_range} :
#line 53 "argcheck.l"
{ return token::TINT; } // to prevent {symbol} longest match in i2..4 case
            break;
          case 9: // rule argcheck.l:54: \+ :
#line 54 "argcheck.l"
{ return token::PLUS; }
            break;
          case 10: // rule argcheck.l:55: \* :
#line 55 "argcheck.l"
{ return token::ASTERISK; }
            break;
          case 11: // rule argcheck.l:56: \? :
#line 56 "argcheck.l"
{ return token::QUESTION; }
            break;
          case 12: // rule argcheck.l:57: \[ :
#line 57 "argcheck.l"
{ return token::REPEAT_START; }
            break;
          case 13: // rule argcheck.l:58: \] :
#line 58 "argcheck.l"
{ return token::REPEAT_END; }
            break;
          case 14: // rule argcheck.l:59: \( :
#line 59 "argcheck.l"
{ return token::GROUP_START; }
            break;
          case 15: // rule argcheck.l:60: \) :
#line 60 "argcheck.l"
{ return token::GROUP_END; }
            break;
          case 16: // rule argcheck.l:61: \| :
#line 61 "argcheck.l"
{ return token::OR; }
            break;
          case 17: // rule argcheck.l:62: % :
#line 62 "argcheck.l"
{ return token::MODULUS; }
            break;
          case 18: // rule argcheck.l:63: <= :
#line 63 "argcheck.l"
{ return token::LE; }
            break;
          case 19: // rule argcheck.l:64: < :
#line 64 "argcheck.l"
{ return token::LT; }
            break;
          case 20: // rule argcheck.l:65: >= :
#line 65 "argcheck.l"
{ return token::GE; }
            break;
          case 21: // rule argcheck.l:66: > :
#line 66 "argcheck.l"
{ return token::GT; }
            break;
          case 22: // rule argcheck.l:67: != :
#line 67 "argcheck.l"
{ return token::NE; }
            break;
          case 23: // rule argcheck.l:68: = :
#line 68 "argcheck.l"
{ return token::EQ; }
            break;
          case 24: // rule argcheck.l:69: ~ :
#line 69 "argcheck.l"
{ return token::TILDE; }
            break;
          case 25: // rule argcheck.l:70: \^ :
#line 70 "argcheck.l"
{ return token::CAPS; }
            break;
          case 26: // rule argcheck.l:71: \^2 :
#line 71 "argcheck.l"
{ return token::POWER_OF_TWO; }
            break;
          case 27: // rule argcheck.l:72: \$ :
#line 72 "argcheck.l"
{ return token::DOLLAR; }
            break;
          case 28: // rule argcheck.l:73: {space} :
#line 73 "argcheck.l"
{ ; }
            break;
          case 29: // rule argcheck.l:74: {range} :
#line 74 "argcheck.l"
{ return token::REPEAT_RANGE; }
            break;
          case 30: // rule argcheck.l:75: {int} :
#line 75 "argcheck.l"
{ return ArgCheckParser::make_INTEGER(std::strtol(text(), 0, 10)); }
            break;
          case 31: // rule argcheck.l:76: {float} :
#line 76 "argcheck.l"
{ return ArgCheckParser::make_FLOAT(std::strtod(text(), 0)); }

            break;
          case 32: // rule argcheck.l:78: {sqstring} :
#line 78 "argcheck.l"
{
                    const auto N = strlen(text()) - 2;
                    return ArgCheckParser::make_STRING(std::string(text() + 1, N));
                }

            break;
          case 33: // rule argcheck.l:83: {dqstring} :
#line 83 "argcheck.l"
{
                    const auto N = strlen(text()) - 2;
                    return ArgCheckParser::make_STRING(std::string(text() + 1, N));
                }


            break;
          case 34: // rule argcheck.l:89: {symbol} :
#line 89 "argcheck.l"
{ return ArgCheckParser::make_SYMBOL(text()); }
            break;
          case 35: // rule argcheck.l:90: . :
#line 90 "argcheck.l"
{ return ArgCheckParser::make_SYMBOL(text()); }

            break;
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 93 "argcheck.l"


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace ceammc {
namespace argcheck {

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if (c1 == '~') goto S113;
  if (c1 == '|') goto S98;
  if (c1 == 's') goto S65;
  if (c1 == 'i') goto S72;
  if (c1 == 'f') goto S55;
  if (c1 == 'd') goto S48;
  if ('c' <= c1 && c1 <= 'z') goto S161;
  if (c1 == 'b') goto S41;
  if (c1 == 'a') goto S34;
  if (c1 == '_') goto S161;
  if (c1 == '^') goto S115;
  if (c1 == ']') goto S92;
  if (c1 == '[') goto S90;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if (c1 == '?') goto S88;
  if (c1 == '>') goto S105;
  if (c1 == '=') goto S111;
  if (c1 == '<') goto S102;
  if ('1' <= c1 && c1 <= '9') goto S127;
  if (c1 == '0') goto S131;
  if (c1 == '.') goto S120;
  if (c1 == '-') goto S174;
  if (c1 == '+') goto S82;
  if (c1 == '*') goto S86;
  if (c1 == ')') goto S96;
  if (c1 == '(') goto S94;
  if (c1 == '\'') goto S135;
  if (c1 == '%') goto S100;
  if (c1 == '$') goto S118;
  if (c1 == '"') goto S148;
  if (c1 == '!') goto S108;
  if (c1 == ' ') goto S170;
  if ('\t' <= c1 && c1 <= '\n') goto S170;
  if (0 <= c1) goto S168;
  return m.FSM_HALT(c1);

S34:
  m.FSM_TAKE(1);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S161;
  if (c1 == '.') goto S161;
  return m.FSM_HALT(c1);

S41:
  m.FSM_TAKE(2);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S161;
  if (c1 == '.') goto S161;
  return m.FSM_HALT(c1);

S48:
  m.FSM_TAKE(3);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S161;
  if (c1 == '.') goto S161;
  return m.FSM_HALT(c1);

S55:
  m.FSM_TAKE(4);
  m.FSM_HEAD(0);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S178;
  if (c1 == '.') goto S161;
  if (c1 == '-') goto S185;
  if (c1 == '+') goto S185;
  return m.FSM_HALT(c1);

S65:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S161;
  if (c1 == '.') goto S161;
  return m.FSM_HALT(c1);

S72:
  m.FSM_TAKE(7);
  m.FSM_HEAD(1);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S187;
  if (c1 == '.') goto S161;
  if (c1 == '-') goto S194;
  if (c1 == '+') goto S194;
  return m.FSM_HALT(c1);

S82:
  m.FSM_TAKE(9);
  c1 = m.FSM_CHAR();
  if ('1' <= c1 && c1 <= '9') goto S127;
  if (c1 == '0') goto S131;
  return m.FSM_HALT(c1);

S86:
  m.FSM_TAKE(10);
  return m.FSM_HALT();

S88:
  m.FSM_TAKE(11);
  return m.FSM_HALT();

S90:
  m.FSM_TAKE(12);
  return m.FSM_HALT();

S92:
  m.FSM_TAKE(13);
  return m.FSM_HALT();

S94:
  m.FSM_TAKE(14);
  return m.FSM_HALT();

S96:
  m.FSM_TAKE(15);
  return m.FSM_HALT();

S98:
  m.FSM_TAKE(16);
  return m.FSM_HALT();

S100:
  m.FSM_TAKE(17);
  return m.FSM_HALT();

S102:
  m.FSM_TAKE(19);
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S196;
  return m.FSM_HALT(c1);

S105:
  m.FSM_TAKE(21);
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S198;
  return m.FSM_HALT(c1);

S108:
  m.FSM_TAKE(35);
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S200;
  return m.FSM_HALT(c1);

S111:
  m.FSM_TAKE(23);
  return m.FSM_HALT();

S113:
  m.FSM_TAKE(24);
  return m.FSM_HALT();

S115:
  m.FSM_TAKE(25);
  c1 = m.FSM_CHAR();
  if (c1 == '2') goto S202;
  return m.FSM_HALT(c1);

S118:
  m.FSM_TAKE(27);
  return m.FSM_HALT();

S120:
  m.FSM_TAKE(34);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S161;
  if (c1 == '.') goto S204;
  return m.FSM_HALT(c1);

S127:
  m.FSM_TAKE(30);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S127;
  if (c1 == '.') goto S215;
  return m.FSM_HALT(c1);

S131:
  m.FSM_TAKE(30);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S217;
  if (c1 == '.') goto S215;
  return m.FSM_HALT(c1);

S135:
  m.FSM_TAKE(35);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S260;
  if (241 <= c1 && c1 <= 243) goto S258;
  if (c1 == 240) goto S256;
  if (238 <= c1 && c1 <= 239) goto S254;
  if (c1 == 237) goto S252;
  if (225 <= c1 && c1 <= 236) goto S250;
  if (c1 == 224) goto S248;
  if (194 <= c1 && c1 <= 223) goto S246;
  if (128 <= c1) return m.FSM_HALT(c1);
  if (c1 == '`') goto S222;
  if (c1 == '\'') goto S220;
  if (0 <= c1 && c1 <= 127) goto S234;
  return m.FSM_HALT(c1);

S148:
  m.FSM_TAKE(35);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S302;
  if (241 <= c1 && c1 <= 243) goto S300;
  if (c1 == 240) goto S298;
  if (238 <= c1 && c1 <= 239) goto S296;
  if (c1 == 237) goto S294;
  if (225 <= c1 && c1 <= 236) goto S292;
  if (c1 == 224) goto S290;
  if (194 <= c1 && c1 <= 223) goto S288;
  if (128 <= c1) return m.FSM_HALT(c1);
  if (c1 == '`') goto S264;
  if (c1 == '"') goto S262;
  if (0 <= c1 && c1 <= 127) goto S276;
  return m.FSM_HALT(c1);

S161:
  m.FSM_TAKE(34);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S161;
  if (c1 == '.') goto S161;
  return m.FSM_HALT(c1);

S168:
  m.FSM_TAKE(35);
  return m.FSM_HALT();

S170:
  m.FSM_TAKE(28);
  c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S170;
  if ('\t' <= c1 && c1 <= '\n') goto S170;
  return m.FSM_HALT(c1);

S174:
  m.FSM_TAKE(35);
  c1 = m.FSM_CHAR();
  if ('1' <= c1 && c1 <= '9') goto S127;
  if (c1 == '0') goto S131;
  return m.FSM_HALT(c1);

S178:
  m.FSM_TAKE(34);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S178;
  if (c1 == '.') goto S304;
  return m.FSM_HALT(c1);

S185:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S311;
  return m.FSM_HALT(c1);

S187:
  m.FSM_TAKE(34);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S187;
  if (c1 == '.') goto S314;
  return m.FSM_HALT(c1);

S194:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S321;
  return m.FSM_HALT(c1);

S196:
  m.FSM_TAKE(18);
  return m.FSM_HALT();

S198:
  m.FSM_TAKE(20);
  return m.FSM_HALT();

S200:
  m.FSM_TAKE(22);
  return m.FSM_HALT();

S202:
  m.FSM_TAKE(26);
  return m.FSM_HALT();

S204:
  m.FSM_TAKE(34);
  m.FSM_HEAD(2);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if (c1 == ']') goto S332;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S324;
  if (c1 == '.') goto S161;
  if (c1 == '-') goto S335;
  if (c1 == '+') goto S335;
  return m.FSM_HALT(c1);

S215:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S337;
  return m.FSM_HALT(c1);

S217:
  m.FSM_TAKE(30);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S217;
  return m.FSM_HALT(c1);

S220:
  m.FSM_TAKE(32);
  return m.FSM_HALT();

S222:
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S260;
  if (241 <= c1 && c1 <= 243) goto S258;
  if (c1 == 240) goto S256;
  if (238 <= c1 && c1 <= 239) goto S254;
  if (c1 == 237) goto S252;
  if (225 <= c1 && c1 <= 236) goto S250;
  if (c1 == 224) goto S248;
  if (194 <= c1 && c1 <= 223) goto S246;
  if (128 <= c1) return m.FSM_HALT(c1);
  if (c1 == '`') goto S222;
  if (c1 == '\'') goto S340;
  if (0 <= c1 && c1 <= 127) goto S234;
  return m.FSM_HALT(c1);

S234:
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S260;
  if (241 <= c1 && c1 <= 243) goto S258;
  if (c1 == 240) goto S256;
  if (238 <= c1 && c1 <= 239) goto S254;
  if (c1 == 237) goto S252;
  if (225 <= c1 && c1 <= 236) goto S250;
  if (c1 == 224) goto S248;
  if (194 <= c1 && c1 <= 223) goto S246;
  if (128 <= c1) return m.FSM_HALT(c1);
  if (c1 == '`') goto S222;
  if (c1 == '\'') goto S220;
  if (0 <= c1 && c1 <= 127) goto S234;
  return m.FSM_HALT(c1);

S246:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S234;
  return m.FSM_HALT(c1);

S248:
  c1 = m.FSM_CHAR();
  if (160 <= c1 && c1 <= 191) goto S353;
  return m.FSM_HALT(c1);

S250:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S355;
  return m.FSM_HALT(c1);

S252:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 159) goto S357;
  return m.FSM_HALT(c1);

S254:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S359;
  return m.FSM_HALT(c1);

S256:
  c1 = m.FSM_CHAR();
  if (144 <= c1 && c1 <= 191) goto S361;
  return m.FSM_HALT(c1);

S258:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S363;
  return m.FSM_HALT(c1);

S260:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 143) goto S365;
  return m.FSM_HALT(c1);

S262:
  m.FSM_TAKE(33);
  return m.FSM_HALT();

S264:
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S302;
  if (241 <= c1 && c1 <= 243) goto S300;
  if (c1 == 240) goto S298;
  if (238 <= c1 && c1 <= 239) goto S296;
  if (c1 == 237) goto S294;
  if (225 <= c1 && c1 <= 236) goto S292;
  if (c1 == 224) goto S290;
  if (194 <= c1 && c1 <= 223) goto S288;
  if (128 <= c1) return m.FSM_HALT(c1);
  if (c1 == '`') goto S264;
  if (c1 == '"') goto S367;
  if (0 <= c1 && c1 <= 127) goto S276;
  return m.FSM_HALT(c1);

S276:
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S302;
  if (241 <= c1 && c1 <= 243) goto S300;
  if (c1 == 240) goto S298;
  if (238 <= c1 && c1 <= 239) goto S296;
  if (c1 == 237) goto S294;
  if (225 <= c1 && c1 <= 236) goto S292;
  if (c1 == 224) goto S290;
  if (194 <= c1 && c1 <= 223) goto S288;
  if (128 <= c1) return m.FSM_HALT(c1);
  if (c1 == '`') goto S264;
  if (c1 == '"') goto S262;
  if (0 <= c1 && c1 <= 127) goto S276;
  return m.FSM_HALT(c1);

S288:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S276;
  return m.FSM_HALT(c1);

S290:
  c1 = m.FSM_CHAR();
  if (160 <= c1 && c1 <= 191) goto S380;
  return m.FSM_HALT(c1);

S292:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S382;
  return m.FSM_HALT(c1);

S294:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 159) goto S384;
  return m.FSM_HALT(c1);

S296:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S386;
  return m.FSM_HALT(c1);

S298:
  c1 = m.FSM_CHAR();
  if (144 <= c1 && c1 <= 191) goto S388;
  return m.FSM_HALT(c1);

S300:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S390;
  return m.FSM_HALT(c1);

S302:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 143) goto S392;
  return m.FSM_HALT(c1);

S304:
  m.FSM_TAKE(34);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S403;
  if (c1 == '.') goto S394;
  return m.FSM_HALT(c1);

S311:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S311;
  if (c1 == '.') goto S410;
  return m.FSM_HALT(c1);

S314:
  m.FSM_TAKE(34);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S161;
  if (c1 == '.') goto S413;
  return m.FSM_HALT(c1);

S321:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S321;
  if (c1 == '.') goto S422;
  return m.FSM_HALT(c1);

S324:
  m.FSM_TAKE(29);
  m.FSM_TAIL(2);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S324;
  if (c1 == '.') goto S424;
  return m.FSM_HALT(c1);

S332:
  m.FSM_TAKE(29);
  m.FSM_TAIL(2);
  return m.FSM_HALT();

S335:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S431;
  return m.FSM_HALT(c1);

S337:
  m.FSM_TAKE(31);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S337;
  return m.FSM_HALT(c1);

S340:
  m.FSM_TAKE(32);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S260;
  if (241 <= c1 && c1 <= 243) goto S258;
  if (c1 == 240) goto S256;
  if (238 <= c1 && c1 <= 239) goto S254;
  if (c1 == 237) goto S252;
  if (225 <= c1 && c1 <= 236) goto S250;
  if (c1 == 224) goto S248;
  if (194 <= c1 && c1 <= 223) goto S246;
  if (128 <= c1) return m.FSM_HALT(c1);
  if (c1 == '`') goto S222;
  if (c1 == '\'') goto S220;
  if (0 <= c1 && c1 <= 127) goto S234;
  return m.FSM_HALT(c1);

S353:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S234;
  return m.FSM_HALT(c1);

S355:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S234;
  return m.FSM_HALT(c1);

S357:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S234;
  return m.FSM_HALT(c1);

S359:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S234;
  return m.FSM_HALT(c1);

S361:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S436;
  return m.FSM_HALT(c1);

S363:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S438;
  return m.FSM_HALT(c1);

S365:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S440;
  return m.FSM_HALT(c1);

S367:
  m.FSM_TAKE(33);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S302;
  if (241 <= c1 && c1 <= 243) goto S300;
  if (c1 == 240) goto S298;
  if (238 <= c1 && c1 <= 239) goto S296;
  if (c1 == 237) goto S294;
  if (225 <= c1 && c1 <= 236) goto S292;
  if (c1 == 224) goto S290;
  if (194 <= c1 && c1 <= 223) goto S288;
  if (128 <= c1) return m.FSM_HALT(c1);
  if (c1 == '`') goto S264;
  if (c1 == '"') goto S262;
  if (0 <= c1 && c1 <= 127) goto S276;
  return m.FSM_HALT(c1);

S380:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S276;
  return m.FSM_HALT(c1);

S382:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S276;
  return m.FSM_HALT(c1);

S384:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S276;
  return m.FSM_HALT(c1);

S386:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S276;
  return m.FSM_HALT(c1);

S388:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S442;
  return m.FSM_HALT(c1);

S390:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S444;
  return m.FSM_HALT(c1);

S392:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S446;
  return m.FSM_HALT(c1);

S394:
  m.FSM_TAKE(34);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S448;
  if (c1 == '.') goto S161;
  if (c1 == '-') goto S456;
  if (c1 == '+') goto S456;
  return m.FSM_HALT(c1);

S403:
  m.FSM_TAKE(34);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S403;
  if (c1 == '.') goto S458;
  return m.FSM_HALT(c1);

S410:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S469;
  if (c1 == '.') goto S465;
  return m.FSM_HALT(c1);

S413:
  m.FSM_TAKE(34);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S472;
  if (c1 == '.') goto S161;
  if (c1 == '-') goto S480;
  if (c1 == '+') goto S480;
  return m.FSM_HALT(c1);

S422:
  c1 = m.FSM_CHAR();
  if (c1 == '.') goto S482;
  return m.FSM_HALT(c1);

S424:
  m.FSM_TAKE(34);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S486;
  if (c1 == '.') goto S161;
  return m.FSM_HALT(c1);

S431:
  m.FSM_TAKE(29);
  m.FSM_TAIL(2);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S431;
  if (c1 == '.') goto S494;
  return m.FSM_HALT(c1);

S436:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S234;
  return m.FSM_HALT(c1);

S438:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S234;
  return m.FSM_HALT(c1);

S440:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S234;
  return m.FSM_HALT(c1);

S442:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S276;
  return m.FSM_HALT(c1);

S444:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S276;
  return m.FSM_HALT(c1);

S446:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S276;
  return m.FSM_HALT(c1);

S448:
  m.FSM_TAKE(5);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S448;
  if (c1 == '.') goto S496;
  return m.FSM_HALT(c1);

S456:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S503;
  return m.FSM_HALT(c1);

S458:
  m.FSM_TAKE(34);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S161;
  if (c1 == '.') goto S394;
  return m.FSM_HALT(c1);

S465:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S503;
  if (c1 == '-') goto S456;
  if (c1 == '+') goto S456;
  return m.FSM_HALT(c1);

S469:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S469;
  if (c1 == '.') goto S508;
  return m.FSM_HALT(c1);

S472:
  m.FSM_TAKE(8);
  m.FSM_TAIL(1);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S472;
  if (c1 == '.') goto S161;
  return m.FSM_HALT(c1);

S480:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S510;
  return m.FSM_HALT(c1);

S482:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S510;
  if (c1 == '-') goto S480;
  if (c1 == '+') goto S480;
  return m.FSM_HALT(c1);

S486:
  m.FSM_TAKE(29);
  m.FSM_TAIL(2);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S486;
  if (c1 == '.') goto S161;
  return m.FSM_HALT(c1);

S494:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S514;
  return m.FSM_HALT(c1);

S496:
  m.FSM_TAKE(34);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S518;
  if (c1 == '.') goto S161;
  return m.FSM_HALT(c1);

S503:
  m.FSM_TAKE(5);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S503;
  if (c1 == '.') goto S526;
  return m.FSM_HALT(c1);

S508:
  c1 = m.FSM_CHAR();
  if (c1 == '.') goto S465;
  return m.FSM_HALT(c1);

S510:
  m.FSM_TAKE(8);
  m.FSM_TAIL(1);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S510;
  return m.FSM_HALT(c1);

S514:
  m.FSM_TAKE(29);
  m.FSM_TAIL(2);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S514;
  return m.FSM_HALT(c1);

S518:
  m.FSM_TAKE(5);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S161;
  if (c1 == '_') goto S161;
  if ('A' <= c1 && c1 <= 'Z') goto S161;
  if ('0' <= c1 && c1 <= '9') goto S518;
  if (c1 == '.') goto S161;
  return m.FSM_HALT(c1);

S526:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S528;
  return m.FSM_HALT(c1);

S528:
  m.FSM_TAKE(5);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S528;
  return m.FSM_HALT(c1);
}

} // namespace ceammc

} // namespace argcheck

