// array_loader.lexer.cpp generated by reflex 1.6.3 from array_loader.l

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_YYLTYPE             ceammc::location
#define REFLEX_OPTION_YYSTYPE             ceammc::ArrayLoaderParser::semantic_type
#define REFLEX_OPTION_bison_cc            true
#define REFLEX_OPTION_bison_cc_namespace  ceammc
#define REFLEX_OPTION_bison_cc_parser     ArrayLoaderParser
#define REFLEX_OPTION_bison_complete      true
#define REFLEX_OPTION_bison_locations     true
#define REFLEX_OPTION_debug               true
#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_freespace           true
#define REFLEX_OPTION_header_file         "array_loader.lexer.h"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               ArrayLoaderLexer
#define REFLEX_OPTION_namespace           ceammc
#define REFLEX_OPTION_noindent            true
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "array_loader.lexer.cpp"
#define REFLEX_OPTION_reentrant           true
#define REFLEX_OPTION_token_eof           ceammc::ArrayLoaderParser::symbol_type(0, location())
#define REFLEX_OPTION_token_type          ceammc::ArrayLoaderParser::symbol_type
#define REFLEX_OPTION_unicode             true

// --debug option enables ASSERT:
#define ASSERT(c) assert(c)

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top{ user code %}                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "array_loader.l"

    # include <string>
    # include <memory>
    # include <cstdint>
    # include <cmath>

    # include "lex/array_loader.parser.hpp"

    using token = ceammc::ArrayLoaderParser::token;


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define WITH_NO_INDENT
#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace ceammc {

class ArrayLoaderLexer : public reflex::AbstractLexer<reflex::Matcher> {
#line 12 "array_loader.l"

    private:
        std::size_t pat_count_ = {0};
        std::string pat_prefix_;
        std::string pat_suffix_;
        std::vector<std::string> patterns_;
        std::pair<uint, uint> pat_range_ = {0, 0};
        std::vector<uint8_t> channels_;
        bool finished_ = {false};

        size_t output_indent_ = {0};

    public:
        /** return string for output indent */
        inline std::string indent(size_t n = 0, char c = ' ') const {
            return std::string(output_indent_ + n, c);
        }

        /** set debug output indent */
        inline void setOutputIndent(size_t n) { output_indent_ = n; }

 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  ArrayLoaderLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
    set_debug(true);
  }
  static const int INITIAL = 0;
  static const int ARRAY = 1;
  static const int PATTERN = 2;
  static const int RANGE = 3;
  static const int VARIANT = 4;
  static const int OPTIONS = 5;
  static const int SMPTE = 6;
  virtual ceammc::location location(void) const
  {
    ceammc::location yylloc;
    yylloc.begin.line = static_cast<unsigned int>(matcher().lineno());
    yylloc.begin.column = static_cast<unsigned int>(matcher().columno());
    yylloc.end.line = static_cast<unsigned int>(matcher().lineno_end());
    yylloc.end.column = static_cast<unsigned int>(matcher().columno_end());
    return yylloc;
  }
  virtual ceammc::ArrayLoaderParser::symbol_type lex(void);
};

} // namespace ceammc

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 39 "array_loader.l"
/*%option graphs-file*/
#line 41 "array_loader.l"
/*%option perf-report*/

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON C++                                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace ceammc {
extern void reflex_code_INITIAL(reflex::Matcher&);
} // namespace ceammc
namespace ceammc {
extern void reflex_code_ARRAY(reflex::Matcher&);
} // namespace ceammc
namespace ceammc {
extern void reflex_code_PATTERN(reflex::Matcher&);
} // namespace ceammc
namespace ceammc {
extern void reflex_code_RANGE(reflex::Matcher&);
} // namespace ceammc
namespace ceammc {
extern void reflex_code_VARIANT(reflex::Matcher&);
} // namespace ceammc
namespace ceammc {
extern void reflex_code_OPTIONS(reflex::Matcher&);
} // namespace ceammc
namespace ceammc {
extern void reflex_code_SMPTE(reflex::Matcher&);
} // namespace ceammc

ceammc::ArrayLoaderParser::symbol_type ceammc::ArrayLoaderLexer::lex()
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  static const reflex::Pattern PATTERN_ARRAY(reflex_code_ARRAY);
  static const reflex::Pattern PATTERN_PATTERN(reflex_code_PATTERN);
  static const reflex::Pattern PATTERN_RANGE(reflex_code_RANGE);
  static const reflex::Pattern PATTERN_VARIANT(reflex_code_VARIANT);
  static const reflex::Pattern PATTERN_OPTIONS(reflex_code_OPTIONS);
  static const reflex::Pattern PATTERN_SMPTE(reflex_code_SMPTE);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
    switch (start())
    {
      case INITIAL:
        matcher().pattern(PATTERN_INITIAL);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              if (debug()) std::cerr << "--\033[1;35mEOF rule at line 205\033[0m (start condition " << start() << ")\n";
#line 205 "array_loader.l"
{ return ArrayLoaderParser::make_STRING_END(location()); }
            }
            else
            {
              if (debug()) std::cerr << "--\033[1;31maccepting default rule\033[0m\n";
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 90: (?:[\x09\x0a\x20]+)
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 90\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 90 "array_loader.l"
            break;
          case 2: // rule at line 91: load(?=(?:[\x09\x0a\x20]+))
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 91\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 91 "array_loader.l"
{ return ArrayLoaderParser::make_ACT_LOAD(location()); }

            break;
          case 3: // rule at line 93: (?:(?:[\x00-\x08]|[\x0b-\x1f]|[!-\x7f]|[\xc2-\xdf][\x80-\xbf]|\xe0[\xa0-\xbf][\x80-\xbf]|[\xe1-\xec][\x80-\xbf][\x80-\xbf]|\xed[\x80-\x9f][\x80-\xbf]|[\xee\xef][\x80-\xbf][\x80-\xbf]|\xf0[\x90-\xbf][\x80-\xbf][\x80-\xbf]|[\xf1-\xf3][\x80-\xbf][\x80-\xbf][\x80-\xbf]|\xf4[\x80-\x8f][\x80-\xbf][\x80-\xbf])+)
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 93\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 93 "array_loader.l"
{ return ArrayLoaderParser::make_SYMBOL(text(), location()); }
            break;
          case 4: // rule at line 94: (?:"(?:(?:[\x00-!]|[\x23-_]|[a-\x7f]|[\xc2-\xdf][\x80-\xbf]|\xe0[\xa0-\xbf][\x80-\xbf]|[\xe1-\xec][\x80-\xbf][\x80-\xbf]|\xed[\x80-\x9f][\x80-\xbf]|[\xee\xef][\x80-\xbf][\x80-\xbf]|\xf0[\x90-\xbf][\x80-\xbf][\x80-\xbf]|[\xf1-\xf3][\x80-\xbf][\x80-\xbf][\x80-\xbf]|\xf4[\x80-\x8f][\x80-\xbf][\x80-\xbf])|`"|``|`\.|`:|`\(|`\))*")
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 94\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 94 "array_loader.l"
{
                          std::string str(text() + 1);
                          str.pop_back();
                          return ArrayLoaderParser::make_QUOTED_STRING(str, location());
                        }

            break;
          case 5: // rule at line 100: (?:[@]?to)(?:[\x09\x0a\x20]+)
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 100\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 100 "array_loader.l"
{
                            start(ARRAY);
                            pat_count_ = 0;
                            patterns_.clear();
                            pat_prefix_.clear();
                            pat_suffix_.clear();

                            out() << "array start\n";
                        }

            break;
          case 6: // rule at line 206: .
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 206\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 206 "array_loader.l"
{ return ArrayLoaderParser::make_LEXER_ERROR(location()); /* error */ }

            break;
        }
        break;
      case ARRAY:
        matcher().pattern(PATTERN_ARRAY);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              if (debug()) std::cerr << "--\033[1;35mEOF rule at line 161\033[0m (start condition " << start() << ")\n";
#line 161 "array_loader.l"
{
                            if(!finished_) {
                                finished_ = true;
                                return ArrayLoaderParser::make_ARRAY_LIST({}, location());
                            }
                            else
                                return ArrayLoaderParser::make_STRING_END(location());
                        }
            }
            else
            {
              if (debug()) std::cerr << "--\033[1;31maccepting default rule\033[0m\n";
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 110: (?:[\x00-\x08]|[\x0e-\x1f]|[!-Z]|\x5c|[\x5e-\x7f]|\xc2[\x80-\x9f]|\xc2[\xa1-\xbf]|[\xc3-\xdf][\x80-\xbf]|\xe0[\xa0-\xbf][\x80-\xbf]|\xe1[\x80-\x99][\x80-\xbf]|\xe1(?:\x9a[\x81-\xbf]|[\x9b-\xbf][\x80-\xbf])|\xe2\x80[\x8b-\xae]|\xe2(?:\x80[\xb0-\xbf]|\x81[\x80-\x9e])|\xe2(?:\x81[\xa0-\xbf]|[\x82-\xbf][\x80-\xbf])|\xe3(?:[\x81-\xbf][\x80-\xbf]|\x80[\x81-\xbf])|[\xe4-\xec][\x80-\xbf][\x80-\xbf]|\xed[\x80-\x9f][\x80-\xbf]|[\xee\xef][\x80-\xbf][\x80-\xbf]|\xf0[\x90-\xbf][\x80-\xbf][\x80-\xbf]|[\xf1-\xf3][\x80-\xbf][\x80-\xbf][\x80-\xbf]|\xf4[\x80-\x8f][\x80-\xbf][\x80-\xbf])*
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 110\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 110 "array_loader.l"
{   // before pattern
                            if(pat_count_ == 0)
                                pat_prefix_ += text();
                            else
                                pat_suffix_ += text();
                        }

            break;
          case 2: // rule at line 117: \[
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 117\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 117 "array_loader.l"
{   // pattern found
                            if(pat_count_++ > 0) {
                                out() << "only one pattern allowed:\n";
                                out() << matcher().line() << "\n";
                                out() << std::string(location().begin.column, '_') << "^\n";
                                return ArrayLoaderParser::make_LEXER_ERROR(location());
                            } else {
                                start(PATTERN);
                                out() << "pattern start\n";
                            }
                        }

            break;
          case 3: // rule at line 169: (?:[\x09\x0a\x20]+)
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 169\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 169 "array_loader.l"
{
                            start(OPTIONS);
                            finished_ = true;
                            return ArrayLoaderParser::make_ARRAY_LIST({}, location());
                        }

            break;
          case 4: // rule at line 206: .
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 206\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 206 "array_loader.l"
{ return ArrayLoaderParser::make_LEXER_ERROR(location()); /* error */ }

            break;
        }
        break;
      case PATTERN:
        matcher().pattern(PATTERN_PATTERN);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              if (debug()) std::cerr << "--\033[1;35mEOF rule at line 205\033[0m (start condition " << start() << ")\n";
#line 205 "array_loader.l"
{ return ArrayLoaderParser::make_STRING_END(location()); }
            }
            else
            {
              if (debug()) std::cerr << "--\033[1;31maccepting default rule\033[0m\n";
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 131: \]
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 131\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 131 "array_loader.l"
{   // pattern end
                            start(ARRAY);
                            out() << "pattern end\n";

                            if(patterns_.empty()) {
                                for(char c = '0'; c <= '9'; c++)
                                    patterns_.push_back(std::string(1, c));
                            }

                        }

            break;
          case 2: // rule at line 142: (?:0|[1-9][0-9]*)-
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 142\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 142 "array_loader.l"
{ start(RANGE); pat_range_.first = std::stoi(text()); }
            break;
          case 3: // rule at line 143: [0-9A-Za-z]+(?=\|)
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 143\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 143 "array_loader.l"
{ patterns_.emplace_back(text()); }
            break;
          case 4: // rule at line 144: [0-9A-Za-z]+(?=\])
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 144\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 144 "array_loader.l"
{ patterns_.emplace_back(text()); }
            break;
          case 5: // rule at line 145: \|
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 145\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 145 "array_loader.l"
            break;
          case 6: // rule at line 206: .
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 206\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 206 "array_loader.l"
{ return ArrayLoaderParser::make_LEXER_ERROR(location()); /* error */ }

            break;
        }
        break;
      case RANGE:
        matcher().pattern(PATTERN_RANGE);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              if (debug()) std::cerr << "--\033[1;35mEOF rule at line 205\033[0m (start condition " << start() << ")\n";
#line 205 "array_loader.l"
{ return ArrayLoaderParser::make_STRING_END(location()); }
            }
            else
            {
              if (debug()) std::cerr << "--\033[1;31maccepting default rule\033[0m\n";
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 148: (?:0|[1-9][0-9]*)(?=\])
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 148\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 148 "array_loader.l"
{
                            start(PATTERN);
                            pat_range_.second = std::stoi(text());

                            if(pat_range_.first > pat_range_.second) {
                                out() << "invalid range";
                                return ArrayLoaderParser::make_LEXER_ERROR(location());
                            }

                            for(uint i = pat_range_.first; i <= pat_range_.second; i++) {
                                patterns_.push_back(std::to_string(i));
                            }
                        }
            break;
          case 2: // rule at line 206: .
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 206\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 206 "array_loader.l"
{ return ArrayLoaderParser::make_LEXER_ERROR(location()); /* error */ }

            break;
        }
        break;
      case VARIANT:
        matcher().pattern(PATTERN_VARIANT);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              if (debug()) std::cerr << "--\033[1;35mEOF rule at line 205\033[0m (start condition " << start() << ")\n";
#line 205 "array_loader.l"
{ return ArrayLoaderParser::make_STRING_END(location()); }
            }
            else
            {
              if (debug()) std::cerr << "--\033[1;31maccepting default rule\033[0m\n";
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 206: .
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 206\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 206 "array_loader.l"
{ return ArrayLoaderParser::make_LEXER_ERROR(location()); /* error */ }

            break;
        }
        break;
      case OPTIONS:
        matcher().pattern(PATTERN_OPTIONS);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              if (debug()) std::cerr << "--\033[1;35mEOF rule at line 205\033[0m (start condition " << start() << ")\n";
#line 205 "array_loader.l"
{ return ArrayLoaderParser::make_STRING_END(location()); }
            }
            else
            {
              if (debug()) std::cerr << "--\033[1;31maccepting default rule\033[0m\n";
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 175: @(?:(?:b|begin))
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 175\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 175 "array_loader.l"
{ return ArrayLoaderParser::make_BEGIN(location()); }
            break;
          case 2: // rule at line 176: @(?:offset)
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 176\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 176 "array_loader.l"
{   out() << "@offset option is obsolete, use @begin\n";
                            return ArrayLoaderParser::make_BEGIN(location()); }
            break;
          case 3: // rule at line 178: @(?:(?:e|end))
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 178\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 178 "array_loader.l"
{ return ArrayLoaderParser::make_END(location()); }
            break;
          case 4: // rule at line 179: @(?:(?:g|gain))
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 179\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 179 "array_loader.l"
{ return ArrayLoaderParser::make_GAIN(location()); }
            break;
          case 5: // rule at line 180: @(?:(?:l|len|length))
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 180\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 180 "array_loader.l"
{ return ArrayLoaderParser::make_LENGTH(location()); }
            break;
          case 6: // rule at line 181: @(?:(?:n|norm|normalize))
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 181\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 181 "array_loader.l"
{ return ArrayLoaderParser::make_NORMALIZE(location()); }
            break;
          case 7: // rule at line 182: @(?:resample)
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 182\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 182 "array_loader.l"
{ return ArrayLoaderParser::make_RESAMPLE(location()); }
            break;
          case 8: // rule at line 183: @(?:(?:r|resize))
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 183\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 183 "array_loader.l"
{ return ArrayLoaderParser::make_RESIZE(location()); }
            break;
          case 9: // rule at line 184: @(?:(?:v|verbose))
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 184\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 184 "array_loader.l"
{ return ArrayLoaderParser::make_VERBOSE(location()); }
            break;
          case 10: // rule at line 185: @[a-z]+
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 185\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 185 "array_loader.l"
{   out() << "unexpected option: " << text() << "\n";
                            return ArrayLoaderParser::make_LEXER_ERROR(location()); }

            break;
          case 11: // rule at line 188: (?:[\x09\x0a\x20]+)
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 188\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 188 "array_loader.l"


            break;
          case 12: // rule at line 190: (?:[0-9]{2}:[0-9]{2}(?::[0-9]{2})?(?:(?:.[\x80-\xbf]*)[0-9]{2})?)
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 190\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 190 "array_loader.l"
{ start(SMPTE); matcher().less(0); }
            break;
          case 13: // rule at line 191: (?:[\x2b\x2d]?(?:0|[1-9][0-9]*))
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 191\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 191 "array_loader.l"
{ return ArrayLoaderParser::make_INT(std::stoi(text()), location()); }
            break;
          case 14: // rule at line 192: (?:(?:[\x2b\x2d]?(?:0|[1-9][0-9]*))(?:\.[0-9]+)?)
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 192\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 192 "array_loader.l"
{ return ArrayLoaderParser::make_FLOAT(std::stod(text()), location()); }
            break;
          case 15: // rule at line 193: (?:ms|msec)
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 193\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 193 "array_loader.l"
{ return ArrayLoaderParser::make_MSEC(location()); }
            break;
          case 16: // rule at line 194: (?:s|sec)
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 194\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 194 "array_loader.l"
{ return ArrayLoaderParser::make_SEC(location()); }
            break;
          case 17: // rule at line 195: (?:db)
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 195\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 195 "array_loader.l"
{ return ArrayLoaderParser::make_DB(location()); }
            break;
          case 18: // rule at line 196: (?:samp|samples)
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 196\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 196 "array_loader.l"
{ return ArrayLoaderParser::make_SAMPLES(location()); }
            break;
          case 19: // rule at line 197: /
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 197\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 197 "array_loader.l"
{ return ArrayLoaderParser::make_FRAC(location()); }

            break;
          case 20: // rule at line 206: .
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 206\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 206 "array_loader.l"
{ return ArrayLoaderParser::make_LEXER_ERROR(location()); /* error */ }

            break;
        }
        break;
      case SMPTE:
        matcher().pattern(PATTERN_SMPTE);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              if (debug()) std::cerr << "--\033[1;35mEOF rule at line 205\033[0m (start condition " << start() << ")\n";
#line 205 "array_loader.l"
{ return ArrayLoaderParser::make_STRING_END(location()); }
            }
            else
            {
              if (debug()) std::cerr << "--\033[1;31maccepting default rule\033[0m\n";
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 199: [0-9][0-9]
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 199\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 199 "array_loader.l"
{ return ArrayLoaderParser::make_UINT(std::stoi(text(), nullptr, 10), location()); }
            break;
          case 2: // rule at line 200: :
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 200\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 200 "array_loader.l"
{ return ArrayLoaderParser::make_COLON(location()); }
            break;
          case 3: // rule at line 201: \.
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 201\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 201 "array_loader.l"
{ return ArrayLoaderParser::make_DOT(location()); }
            break;
          case 4: // rule at line 202: @
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 202\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 202 "array_loader.l"
{ start(OPTIONS); matcher().less(0); /*push back '@' and go to OPTIONS*/  }


            break;
          case 5: // rule at line 206: .
            if (debug()) std::cerr << "--\033[1;35maccepting rule at line 206\033[0m (\"\033[1m" << matcher().text() << "\033[0m\")\n";
#line 206 "array_loader.l"
{ return ArrayLoaderParser::make_LEXER_ERROR(location()); /* error */ }

            break;
        }
        break;
      default:
        start(0);
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace ceammc {

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S99;
  if (241 <= c1 && c1 <= 243) goto S96;
  if (c1 == 240) goto S93;
  if (238 <= c1 && c1 <= 239) goto S90;
  if (c1 == 237) goto S87;
  if (225 <= c1 && c1 <= 236) goto S84;
  if (c1 == 224) goto S81;
  if (194 <= c1 && c1 <= 223) goto S78;
  if (128 <= c1) goto S59;
  if (c1 == 't') goto S45;
  if (c1 == 'l') goto S16;
  if (c1 == '@') goto S102;
  if (c1 == '"') goto S30;
  if (c1 == ' ') goto S61;
  if ('\t' <= c1 && c1 <= '\n') goto S61;
  if (0 <= c1 && c1 <= 127) goto S65;
  return m.FSM_HALT(c1);

S16:
  m.FSM_TAKE(3);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S144;
  if (241 <= c1 && c1 <= 243) goto S142;
  if (c1 == 240) goto S140;
  if (238 <= c1 && c1 <= 239) goto S138;
  if (c1 == 237) goto S136;
  if (225 <= c1 && c1 <= 236) goto S134;
  if (c1 == 224) goto S132;
  if (194 <= c1 && c1 <= 223) goto S130;
  if (c1 == 'o') goto S116;
  if ('!' <= c1 && c1 <= 127) goto S65;
  if ('\v' <= c1 && c1 <= 31) goto S65;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S65;
  return m.FSM_HALT(c1);

S30:
  m.FSM_TAKE(3);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S178;
  if (241 <= c1 && c1 <= 243) goto S176;
  if (c1 == 240) goto S174;
  if (238 <= c1 && c1 <= 239) goto S172;
  if (c1 == 237) goto S170;
  if (225 <= c1 && c1 <= 236) goto S168;
  if (c1 == 224) goto S166;
  if (194 <= c1 && c1 <= 223) goto S164;
  if (128 <= c1) return m.FSM_HALT(c1);
  if (c1 == '`') goto S146;
  if (c1 == '"') goto S65;
  if (c1 == ' ') goto S180;
  if ('\t' <= c1 && c1 <= '\n') goto S180;
  if (0 <= c1 && c1 <= 127) goto S30;
  return m.FSM_HALT(c1);

S45:
  m.FSM_TAKE(3);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S144;
  if (241 <= c1 && c1 <= 243) goto S142;
  if (c1 == 240) goto S140;
  if (238 <= c1 && c1 <= 239) goto S138;
  if (c1 == 237) goto S136;
  if (225 <= c1 && c1 <= 236) goto S134;
  if (c1 == 224) goto S132;
  if (194 <= c1 && c1 <= 223) goto S130;
  if (c1 == 'o') goto S192;
  if ('!' <= c1 && c1 <= 127) goto S65;
  if ('\v' <= c1 && c1 <= 31) goto S65;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S65;
  return m.FSM_HALT(c1);

S59:
  m.FSM_TAKE(6);
  return m.FSM_HALT();

S61:
  m.FSM_TAKE(1);
  c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S61;
  if ('\t' <= c1 && c1 <= '\n') goto S61;
  return m.FSM_HALT(c1);

S65:
  m.FSM_TAKE(3);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S144;
  if (241 <= c1 && c1 <= 243) goto S142;
  if (c1 == 240) goto S140;
  if (238 <= c1 && c1 <= 239) goto S138;
  if (c1 == 237) goto S136;
  if (225 <= c1 && c1 <= 236) goto S134;
  if (c1 == 224) goto S132;
  if (194 <= c1 && c1 <= 223) goto S130;
  if ('!' <= c1 && c1 <= 127) goto S65;
  if ('\v' <= c1 && c1 <= 31) goto S65;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S65;
  return m.FSM_HALT(c1);

S78:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S65;
  return m.FSM_HALT(c1);

S81:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (160 <= c1 && c1 <= 191) goto S205;
  return m.FSM_HALT(c1);

S84:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S207;
  return m.FSM_HALT(c1);

S87:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 159) goto S209;
  return m.FSM_HALT(c1);

S90:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S211;
  return m.FSM_HALT(c1);

S93:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (144 <= c1 && c1 <= 191) goto S213;
  return m.FSM_HALT(c1);

S96:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S215;
  return m.FSM_HALT(c1);

S99:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 143) goto S217;
  return m.FSM_HALT(c1);

S102:
  m.FSM_TAKE(3);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S144;
  if (241 <= c1 && c1 <= 243) goto S142;
  if (c1 == 240) goto S140;
  if (238 <= c1 && c1 <= 239) goto S138;
  if (c1 == 237) goto S136;
  if (225 <= c1 && c1 <= 236) goto S134;
  if (c1 == 224) goto S132;
  if (194 <= c1 && c1 <= 223) goto S130;
  if (c1 == 't') goto S45;
  if ('!' <= c1 && c1 <= 127) goto S65;
  if ('\v' <= c1 && c1 <= 31) goto S65;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S65;
  return m.FSM_HALT(c1);

S116:
  m.FSM_TAKE(3);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S144;
  if (241 <= c1 && c1 <= 243) goto S142;
  if (c1 == 240) goto S140;
  if (238 <= c1 && c1 <= 239) goto S138;
  if (c1 == 237) goto S136;
  if (225 <= c1 && c1 <= 236) goto S134;
  if (c1 == 224) goto S132;
  if (194 <= c1 && c1 <= 223) goto S130;
  if (c1 == 'a') goto S219;
  if ('!' <= c1 && c1 <= 127) goto S65;
  if ('\v' <= c1 && c1 <= 31) goto S65;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S65;
  return m.FSM_HALT(c1);

S130:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S65;
  return m.FSM_HALT(c1);

S132:
  c1 = m.FSM_CHAR();
  if (160 <= c1 && c1 <= 191) goto S205;
  return m.FSM_HALT(c1);

S134:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S207;
  return m.FSM_HALT(c1);

S136:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 159) goto S209;
  return m.FSM_HALT(c1);

S138:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S211;
  return m.FSM_HALT(c1);

S140:
  c1 = m.FSM_CHAR();
  if (144 <= c1 && c1 <= 191) goto S213;
  return m.FSM_HALT(c1);

S142:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S215;
  return m.FSM_HALT(c1);

S144:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 143) goto S217;
  return m.FSM_HALT(c1);

S146:
  m.FSM_TAKE(3);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S144;
  if (241 <= c1 && c1 <= 243) goto S142;
  if (c1 == 240) goto S140;
  if (238 <= c1 && c1 <= 239) goto S138;
  if (c1 == 237) goto S136;
  if (225 <= c1 && c1 <= 236) goto S134;
  if (c1 == 224) goto S132;
  if (194 <= c1 && c1 <= 223) goto S130;
  if (c1 == '`') goto S30;
  if (c1 == ':') goto S30;
  if (c1 == '.') goto S30;
  if ('(' <= c1 && c1 <= ')') goto S30;
  if (c1 == '"') goto S30;
  if ('!' <= c1 && c1 <= 127) goto S65;
  if ('\v' <= c1 && c1 <= 31) goto S65;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S65;
  return m.FSM_HALT(c1);

S164:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S30;
  return m.FSM_HALT(c1);

S166:
  c1 = m.FSM_CHAR();
  if (160 <= c1 && c1 <= 191) goto S233;
  return m.FSM_HALT(c1);

S168:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S235;
  return m.FSM_HALT(c1);

S170:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 159) goto S237;
  return m.FSM_HALT(c1);

S172:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S239;
  return m.FSM_HALT(c1);

S174:
  c1 = m.FSM_CHAR();
  if (144 <= c1 && c1 <= 191) goto S241;
  return m.FSM_HALT(c1);

S176:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S243;
  return m.FSM_HALT(c1);

S178:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 143) goto S245;
  return m.FSM_HALT(c1);

S180:
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S263;
  if (241 <= c1 && c1 <= 243) goto S261;
  if (c1 == 240) goto S259;
  if (238 <= c1 && c1 <= 239) goto S257;
  if (c1 == 237) goto S255;
  if (225 <= c1 && c1 <= 236) goto S253;
  if (c1 == 224) goto S251;
  if (194 <= c1 && c1 <= 223) goto S249;
  if (128 <= c1) return m.FSM_HALT(c1);
  if (c1 == '`') goto S265;
  if (c1 == '"') goto S247;
  if (0 <= c1 && c1 <= 127) goto S180;
  return m.FSM_HALT(c1);

S192:
  m.FSM_TAKE(3);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S144;
  if (241 <= c1 && c1 <= 243) goto S142;
  if (c1 == 240) goto S140;
  if (238 <= c1 && c1 <= 239) goto S138;
  if (c1 == 237) goto S136;
  if (225 <= c1 && c1 <= 236) goto S134;
  if (c1 == 224) goto S132;
  if (194 <= c1 && c1 <= 223) goto S130;
  if (128 <= c1) return m.FSM_HALT(c1);
  if (c1 == ' ') goto S271;
  if ('\t' <= c1 && c1 <= '\n') goto S271;
  if (0 <= c1 && c1 <= 127) goto S65;
  return m.FSM_HALT(c1);

S205:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S65;
  return m.FSM_HALT(c1);

S207:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S65;
  return m.FSM_HALT(c1);

S209:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S65;
  return m.FSM_HALT(c1);

S211:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S65;
  return m.FSM_HALT(c1);

S213:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S275;
  return m.FSM_HALT(c1);

S215:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S277;
  return m.FSM_HALT(c1);

S217:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S279;
  return m.FSM_HALT(c1);

S219:
  m.FSM_TAKE(3);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S144;
  if (241 <= c1 && c1 <= 243) goto S142;
  if (c1 == 240) goto S140;
  if (238 <= c1 && c1 <= 239) goto S138;
  if (c1 == 237) goto S136;
  if (225 <= c1 && c1 <= 236) goto S134;
  if (c1 == 224) goto S132;
  if (194 <= c1 && c1 <= 223) goto S130;
  if (c1 == 'd') goto S281;
  if ('!' <= c1 && c1 <= 127) goto S65;
  if ('\v' <= c1 && c1 <= 31) goto S65;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S65;
  return m.FSM_HALT(c1);

S233:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S30;
  return m.FSM_HALT(c1);

S235:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S30;
  return m.FSM_HALT(c1);

S237:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S30;
  return m.FSM_HALT(c1);

S239:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S30;
  return m.FSM_HALT(c1);

S241:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S295;
  return m.FSM_HALT(c1);

S243:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S297;
  return m.FSM_HALT(c1);

S245:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S299;
  return m.FSM_HALT(c1);

S247:
  m.FSM_TAKE(4);
  return m.FSM_HALT();

S249:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S180;
  return m.FSM_HALT(c1);

S251:
  c1 = m.FSM_CHAR();
  if (160 <= c1 && c1 <= 191) goto S301;
  return m.FSM_HALT(c1);

S253:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S303;
  return m.FSM_HALT(c1);

S255:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 159) goto S305;
  return m.FSM_HALT(c1);

S257:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S307;
  return m.FSM_HALT(c1);

S259:
  c1 = m.FSM_CHAR();
  if (144 <= c1 && c1 <= 191) goto S309;
  return m.FSM_HALT(c1);

S261:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S311;
  return m.FSM_HALT(c1);

S263:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 143) goto S313;
  return m.FSM_HALT(c1);

S265:
  c1 = m.FSM_CHAR();
  if (c1 == '`') goto S180;
  if (c1 == ':') goto S180;
  if (c1 == '.') goto S180;
  if ('(' <= c1 && c1 <= ')') goto S180;
  if (c1 == '"') goto S180;
  return m.FSM_HALT(c1);

S271:
  m.FSM_TAKE(5);
  c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S271;
  if ('\t' <= c1 && c1 <= '\n') goto S271;
  return m.FSM_HALT(c1);

S275:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S65;
  return m.FSM_HALT(c1);

S277:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S65;
  return m.FSM_HALT(c1);

S279:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S65;
  return m.FSM_HALT(c1);

S281:
  m.FSM_TAKE(3);
  m.FSM_HEAD(0);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S144;
  if (241 <= c1 && c1 <= 243) goto S142;
  if (c1 == 240) goto S140;
  if (238 <= c1 && c1 <= 239) goto S138;
  if (c1 == 237) goto S136;
  if (225 <= c1 && c1 <= 236) goto S134;
  if (c1 == 224) goto S132;
  if (194 <= c1 && c1 <= 223) goto S130;
  if (128 <= c1) return m.FSM_HALT(c1);
  if (c1 == ' ') goto S315;
  if ('\t' <= c1 && c1 <= '\n') goto S315;
  if (0 <= c1 && c1 <= 127) goto S65;
  return m.FSM_HALT(c1);

S295:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S30;
  return m.FSM_HALT(c1);

S297:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S30;
  return m.FSM_HALT(c1);

S299:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S30;
  return m.FSM_HALT(c1);

S301:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S180;
  return m.FSM_HALT(c1);

S303:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S180;
  return m.FSM_HALT(c1);

S305:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S180;
  return m.FSM_HALT(c1);

S307:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S180;
  return m.FSM_HALT(c1);

S309:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S320;
  return m.FSM_HALT(c1);

S311:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S322;
  return m.FSM_HALT(c1);

S313:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S324;
  return m.FSM_HALT(c1);

S315:
  m.FSM_TAKE(2);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S315;
  if ('\t' <= c1 && c1 <= '\n') goto S315;
  return m.FSM_HALT(c1);

S320:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S180;
  return m.FSM_HALT(c1);

S322:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S180;
  return m.FSM_HALT(c1);

S324:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S180;
  return m.FSM_HALT(c1);
}

} // namespace ceammc

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace ceammc {

void reflex_code_ARRAY(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  m.FSM_TAKE(1);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S82;
  if (241 <= c1 && c1 <= 243) goto S79;
  if (c1 == 240) goto S76;
  if (238 <= c1 && c1 <= 239) goto S73;
  if (c1 == 237) goto S70;
  if (228 <= c1 && c1 <= 236) goto S67;
  if (c1 == 227) goto S63;
  if (c1 == 226) goto S58;
  if (c1 == 225) goto S53;
  if (c1 == 224) goto S50;
  if (195 <= c1 && c1 <= 223) goto S47;
  if (c1 == 194) goto S43;
  if (128 <= c1) goto S22;
  if (c1 == ']') goto S22;
  if (c1 == '[') goto S20;
  if (c1 == ' ') goto S85;
  if ('\v' <= c1 && c1 <= '\r') goto S22;
  if ('\t' <= c1 && c1 <= '\n') goto S85;
  if (0 <= c1 && c1 <= 127) goto S24;
  return m.FSM_HALT(c1);

S20:
  m.FSM_TAKE(2);
  return m.FSM_HALT();

S22:
  m.FSM_TAKE(4);
  return m.FSM_HALT();

S24:
  m.FSM_TAKE(1);
  c1 = m.FSM_CHAR();
  if (c1 == 244) goto S117;
  if (241 <= c1 && c1 <= 243) goto S115;
  if (c1 == 240) goto S113;
  if (238 <= c1 && c1 <= 239) goto S111;
  if (c1 == 237) goto S109;
  if (228 <= c1 && c1 <= 236) goto S107;
  if (c1 == 227) goto S104;
  if (c1 == 226) goto S100;
  if (c1 == 225) goto S96;
  if (c1 == 224) goto S94;
  if (195 <= c1 && c1 <= 223) goto S92;
  if (c1 == 194) goto S89;
  if ('^' <= c1 && c1 <= 127) goto S24;
  if (c1 == '\\') goto S24;
  if ('!' <= c1 && c1 <= 'Z') goto S24;
  if (14 <= c1 && c1 <= 31) goto S24;
  if ('\t' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\b') goto S24;
  return m.FSM_HALT(c1);

S43:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if (161 <= c1 && c1 <= 191) goto S24;
  if (128 <= c1 && c1 <= 159) goto S24;
  return m.FSM_HALT(c1);

S47:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S24;
  return m.FSM_HALT(c1);

S50:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if (160 <= c1 && c1 <= 191) goto S119;
  return m.FSM_HALT(c1);

S53:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if (155 <= c1 && c1 <= 191) goto S125;
  if (c1 == 154) goto S123;
  if (128 <= c1 && c1 <= 153) goto S121;
  return m.FSM_HALT(c1);

S58:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if (130 <= c1 && c1 <= 191) goto S133;
  if (c1 == 129) goto S130;
  if (c1 == 128) goto S127;
  return m.FSM_HALT(c1);

S63:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if (129 <= c1 && c1 <= 191) goto S135;
  if (c1 == 128) goto S137;
  return m.FSM_HALT(c1);

S67:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S139;
  return m.FSM_HALT(c1);

S70:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 159) goto S141;
  return m.FSM_HALT(c1);

S73:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S143;
  return m.FSM_HALT(c1);

S76:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if (144 <= c1 && c1 <= 191) goto S145;
  return m.FSM_HALT(c1);

S79:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S147;
  return m.FSM_HALT(c1);

S82:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 143) goto S149;
  return m.FSM_HALT(c1);

S85:
  m.FSM_TAKE(3);
  c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S85;
  if ('\t' <= c1 && c1 <= '\n') goto S85;
  return m.FSM_HALT(c1);

S89:
  c1 = m.FSM_CHAR();
  if (161 <= c1 && c1 <= 191) goto S24;
  if (128 <= c1 && c1 <= 159) goto S24;
  return m.FSM_HALT(c1);

S92:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S24;
  return m.FSM_HALT(c1);

S94:
  c1 = m.FSM_CHAR();
  if (160 <= c1 && c1 <= 191) goto S119;
  return m.FSM_HALT(c1);

S96:
  c1 = m.FSM_CHAR();
  if (155 <= c1 && c1 <= 191) goto S125;
  if (c1 == 154) goto S123;
  if (128 <= c1 && c1 <= 153) goto S121;
  return m.FSM_HALT(c1);

S100:
  c1 = m.FSM_CHAR();
  if (130 <= c1 && c1 <= 191) goto S133;
  if (c1 == 129) goto S130;
  if (c1 == 128) goto S127;
  return m.FSM_HALT(c1);

S104:
  c1 = m.FSM_CHAR();
  if (129 <= c1 && c1 <= 191) goto S135;
  if (c1 == 128) goto S137;
  return m.FSM_HALT(c1);

S107:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S139;
  return m.FSM_HALT(c1);

S109:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 159) goto S141;
  return m.FSM_HALT(c1);

S111:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S143;
  return m.FSM_HALT(c1);

S113:
  c1 = m.FSM_CHAR();
  if (144 <= c1 && c1 <= 191) goto S145;
  return m.FSM_HALT(c1);

S115:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S147;
  return m.FSM_HALT(c1);

S117:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 143) goto S149;
  return m.FSM_HALT(c1);

S119:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S24;
  return m.FSM_HALT(c1);

S121:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S24;
  return m.FSM_HALT(c1);

S123:
  c1 = m.FSM_CHAR();
  if (129 <= c1 && c1 <= 191) goto S24;
  return m.FSM_HALT(c1);

S125:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S24;
  return m.FSM_HALT(c1);

S127:
  c1 = m.FSM_CHAR();
  if (176 <= c1 && c1 <= 191) goto S24;
  if (139 <= c1 && c1 <= 174) goto S24;
  return m.FSM_HALT(c1);

S130:
  c1 = m.FSM_CHAR();
  if (160 <= c1 && c1 <= 191) goto S24;
  if (128 <= c1 && c1 <= 158) goto S24;
  return m.FSM_HALT(c1);

S133:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S24;
  return m.FSM_HALT(c1);

S135:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S24;
  return m.FSM_HALT(c1);

S137:
  c1 = m.FSM_CHAR();
  if (129 <= c1 && c1 <= 191) goto S24;
  return m.FSM_HALT(c1);

S139:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S24;
  return m.FSM_HALT(c1);

S141:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S24;
  return m.FSM_HALT(c1);

S143:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S24;
  return m.FSM_HALT(c1);

S145:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S151;
  return m.FSM_HALT(c1);

S147:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S153;
  return m.FSM_HALT(c1);

S149:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S155;
  return m.FSM_HALT(c1);

S151:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S24;
  return m.FSM_HALT(c1);

S153:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S24;
  return m.FSM_HALT(c1);

S155:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S24;
  return m.FSM_HALT(c1);
}

} // namespace ceammc

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace ceammc {

void reflex_code_PATTERN(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if (c1 == '|') goto S31;
  if ('a' <= c1 && c1 <= 'z') goto S35;
  if (c1 == ']') goto S9;
  if ('A' <= c1 && c1 <= 'Z') goto S35;
  if ('1' <= c1 && c1 <= '9') goto S21;
  if (c1 == '0') goto S11;
  if ('\v' <= c1) goto S33;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S33;
  return m.FSM_HALT(c1);

S9:
  m.FSM_TAKE(1);
  return m.FSM_HALT();

S11:
  m.FSM_TAKE(6);
  m.FSM_HEAD(0);
  m.FSM_HEAD(1);
  c1 = m.FSM_CHAR();
  if (c1 == '|') goto S46;
  if ('a' <= c1 && c1 <= 'z') goto S52;
  if (c1 == ']') goto S49;
  if ('A' <= c1 && c1 <= 'Z') goto S52;
  if ('0' <= c1 && c1 <= '9') goto S52;
  if (c1 == '-') goto S44;
  return m.FSM_HALT(c1);

S21:
  m.FSM_TAKE(6);
  m.FSM_HEAD(0);
  m.FSM_HEAD(1);
  c1 = m.FSM_CHAR();
  if (c1 == '|') goto S46;
  if ('a' <= c1 && c1 <= 'z') goto S52;
  if (c1 == ']') goto S49;
  if ('A' <= c1 && c1 <= 'Z') goto S52;
  if ('0' <= c1 && c1 <= '9') goto S60;
  if (c1 == '-') goto S44;
  return m.FSM_HALT(c1);

S31:
  m.FSM_TAKE(5);
  return m.FSM_HALT();

S33:
  m.FSM_TAKE(6);
  return m.FSM_HALT();

S35:
  m.FSM_TAKE(6);
  m.FSM_HEAD(0);
  m.FSM_HEAD(1);
  c1 = m.FSM_CHAR();
  if (c1 == '|') goto S46;
  if ('a' <= c1 && c1 <= 'z') goto S52;
  if (c1 == ']') goto S49;
  if ('A' <= c1 && c1 <= 'Z') goto S52;
  if ('0' <= c1 && c1 <= '9') goto S52;
  return m.FSM_HALT(c1);

S44:
  m.FSM_TAKE(2);
  return m.FSM_HALT();

S46:
  m.FSM_TAKE(3);
  m.FSM_TAIL(0);
  return m.FSM_HALT();

S49:
  m.FSM_TAKE(4);
  m.FSM_TAIL(1);
  return m.FSM_HALT();

S52:
  m.FSM_HEAD(0);
  m.FSM_HEAD(1);
  c1 = m.FSM_CHAR();
  if (c1 == '|') goto S46;
  if ('a' <= c1 && c1 <= 'z') goto S52;
  if (c1 == ']') goto S49;
  if ('A' <= c1 && c1 <= 'Z') goto S52;
  if ('0' <= c1 && c1 <= '9') goto S52;
  return m.FSM_HALT(c1);

S60:
  m.FSM_HEAD(0);
  m.FSM_HEAD(1);
  c1 = m.FSM_CHAR();
  if (c1 == '|') goto S46;
  if ('a' <= c1 && c1 <= 'z') goto S52;
  if (c1 == ']') goto S49;
  if ('A' <= c1 && c1 <= 'Z') goto S52;
  if ('0' <= c1 && c1 <= '9') goto S60;
  if (c1 == '-') goto S44;
  return m.FSM_HALT(c1);
}

} // namespace ceammc

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace ceammc {

void reflex_code_RANGE(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if ('1' <= c1 && c1 <= '9') goto S9;
  if (c1 == '0') goto S5;
  if ('\v' <= c1) goto S14;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S14;
  return m.FSM_HALT(c1);

S5:
  m.FSM_TAKE(2);
  m.FSM_HEAD(0);
  c1 = m.FSM_CHAR();
  if (c1 == ']') goto S16;
  return m.FSM_HALT(c1);

S9:
  m.FSM_TAKE(2);
  m.FSM_HEAD(0);
  c1 = m.FSM_CHAR();
  if (c1 == ']') goto S16;
  if ('0' <= c1 && c1 <= '9') goto S19;
  return m.FSM_HALT(c1);

S14:
  m.FSM_TAKE(2);
  return m.FSM_HALT();

S16:
  m.FSM_TAKE(1);
  m.FSM_TAIL(0);
  return m.FSM_HALT();

S19:
  m.FSM_HEAD(0);
  c1 = m.FSM_CHAR();
  if (c1 == ']') goto S16;
  if ('0' <= c1 && c1 <= '9') goto S19;
  return m.FSM_HALT(c1);
}

} // namespace ceammc

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace ceammc {

void reflex_code_VARIANT(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S3;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S3;
  return m.FSM_HALT(c1);

S3:
  m.FSM_TAKE(1);
  return m.FSM_HALT();
}

} // namespace ceammc

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace ceammc {

void reflex_code_OPTIONS(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S34;
  if (c1 == 'm') goto S31;
  if (c1 == 'd') goto S38;
  if (c1 == '@') goto S12;
  if ('1' <= c1 && c1 <= '9') goto S23;
  if (c1 == '0') goto S27;
  if (c1 == '/') goto S41;
  if (c1 == '-') goto S49;
  if (c1 == '+') goto S49;
  if (c1 == ' ') goto S45;
  if ('\t' <= c1 && c1 <= '\n') goto S45;
  if (0 <= c1) goto S43;
  return m.FSM_HALT(c1);

S12:
  m.FSM_TAKE(20);
  c1 = m.FSM_CHAR();
  if (c1 == 'v') goto S81;
  if (c1 == 'r') goto S77;
  if (c1 == 'o') goto S57;
  if (c1 == 'n') goto S73;
  if (c1 == 'l') goto S69;
  if (c1 == 'g') goto S65;
  if (c1 == 'e') goto S61;
  if (c1 == 'b') goto S53;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S23:
  m.FSM_TAKE(13);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S88;
  if (c1 == '.') goto S93;
  return m.FSM_HALT(c1);

S27:
  m.FSM_TAKE(13);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S95;
  if (c1 == '.') goto S93;
  return m.FSM_HALT(c1);

S31:
  m.FSM_TAKE(20);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S97;
  return m.FSM_HALT(c1);

S34:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S100;
  if (c1 == 'a') goto S102;
  return m.FSM_HALT(c1);

S38:
  m.FSM_TAKE(20);
  c1 = m.FSM_CHAR();
  if (c1 == 'b') goto S104;
  return m.FSM_HALT(c1);

S41:
  m.FSM_TAKE(19);
  return m.FSM_HALT();

S43:
  m.FSM_TAKE(20);
  return m.FSM_HALT();

S45:
  m.FSM_TAKE(11);
  c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S45;
  if ('\t' <= c1 && c1 <= '\n') goto S45;
  return m.FSM_HALT(c1);

S49:
  m.FSM_TAKE(20);
  c1 = m.FSM_CHAR();
  if ('1' <= c1 && c1 <= '9') goto S109;
  if (c1 == '0') goto S106;
  return m.FSM_HALT(c1);

S53:
  m.FSM_TAKE(1);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S113;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S57:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'f') goto S117;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S61:
  m.FSM_TAKE(3);
  c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S121;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S65:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if ('b' <= c1 && c1 <= 'z') goto S85;
  if (c1 == 'a') goto S125;
  return m.FSM_HALT(c1);

S69:
  m.FSM_TAKE(5);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S129;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S73:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (c1 == 'o') goto S133;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S77:
  m.FSM_TAKE(8);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S137;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S81:
  m.FSM_TAKE(9);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S141;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S85:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S88:
  m.FSM_TAKE(13);
  c1 = m.FSM_CHAR();
  if (c1 == ':') goto S145;
  if ('0' <= c1 && c1 <= '9') goto S109;
  if (c1 == '.') goto S93;
  return m.FSM_HALT(c1);

S93:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S147;
  return m.FSM_HALT(c1);

S95:
  c1 = m.FSM_CHAR();
  if (c1 == ':') goto S145;
  return m.FSM_HALT(c1);

S97:
  m.FSM_TAKE(15);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S150;
  return m.FSM_HALT(c1);

S100:
  c1 = m.FSM_CHAR();
  if (c1 == 'c') goto S152;
  return m.FSM_HALT(c1);

S102:
  c1 = m.FSM_CHAR();
  if (c1 == 'm') goto S154;
  return m.FSM_HALT(c1);

S104:
  m.FSM_TAKE(17);
  return m.FSM_HALT();

S106:
  m.FSM_TAKE(13);
  c1 = m.FSM_CHAR();
  if (c1 == '.') goto S93;
  return m.FSM_HALT(c1);

S109:
  m.FSM_TAKE(13);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S109;
  if (c1 == '.') goto S93;
  return m.FSM_HALT(c1);

S113:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'g') goto S156;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S117:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'f') goto S160;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S121:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'd') goto S164;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S125:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'i') goto S167;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S129:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S171;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S133:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'r') goto S175;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S137:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S179;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S141:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'r') goto S184;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S145:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S188;
  return m.FSM_HALT(c1);

S147:
  m.FSM_TAKE(14);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S147;
  return m.FSM_HALT(c1);

S150:
  c1 = m.FSM_CHAR();
  if (c1 == 'c') goto S190;
  return m.FSM_HALT(c1);

S152:
  m.FSM_TAKE(16);
  return m.FSM_HALT();

S154:
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S192;
  return m.FSM_HALT(c1);

S156:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'i') goto S195;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S160:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S199;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S164:
  m.FSM_TAKE(3);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S167:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S203;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S171:
  m.FSM_TAKE(5);
  c1 = m.FSM_CHAR();
  if (c1 == 'g') goto S206;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S175:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'm') goto S210;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S179:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'i') goto S218;
  if ('b' <= c1 && c1 <= 'z') goto S85;
  if (c1 == 'a') goto S214;
  return m.FSM_HALT(c1);

S184:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'b') goto S222;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S188:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S226;
  return m.FSM_HALT(c1);

S190:
  m.FSM_TAKE(15);
  return m.FSM_HALT();

S192:
  m.FSM_TAKE(18);
  c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S231;
  return m.FSM_HALT(c1);

S195:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S233;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S199:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S236;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S203:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S206:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 't') goto S240;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S210:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if ('b' <= c1 && c1 <= 'z') goto S85;
  if (c1 == 'a') goto S244;
  return m.FSM_HALT(c1);

S214:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'm') goto S248;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S218:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'z') goto S252;
  if ('a' <= c1 && c1 <= 'y') goto S85;
  return m.FSM_HALT(c1);

S222:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'o') goto S256;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S226:
  m.FSM_TAKE(12);
  c1 = m.FSM_CHAR();
  if (c1 == ':') goto S260;
  if ('\v' <= c1) goto S263;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S263;
  return m.FSM_HALT(c1);

S231:
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S266;
  return m.FSM_HALT(c1);

S233:
  m.FSM_TAKE(1);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S236:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 't') goto S268;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S240:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'h') goto S271;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S244:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S274;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S248:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S278;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S252:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S282;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S256:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S285;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S260:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S263;
  if ('0' <= c1 && c1 <= '9') goto S289;
  return m.FSM_HALT(c1);

S263:
  c1 = m.FSM_CHAR();
  if (128 <= c1 && c1 <= 191) goto S263;
  if ('0' <= c1 && c1 <= '9') goto S291;
  return m.FSM_HALT(c1);

S266:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S293;
  return m.FSM_HALT(c1);

S268:
  m.FSM_TAKE(2);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S271:
  m.FSM_TAKE(5);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S274:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'i') goto S295;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S278:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S299;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S282:
  m.FSM_TAKE(8);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S285:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S303;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S289:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S306;
  return m.FSM_HALT(c1);

S291:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S310;
  return m.FSM_HALT(c1);

S293:
  m.FSM_TAKE(18);
  return m.FSM_HALT();

S295:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'z') goto S312;
  if ('a' <= c1 && c1 <= 'y') goto S85;
  return m.FSM_HALT(c1);

S299:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S316;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S303:
  m.FSM_TAKE(9);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S306:
  m.FSM_TAKE(12);
  c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S263;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S263;
  return m.FSM_HALT(c1);

S310:
  m.FSM_TAKE(12);
  return m.FSM_HALT();

S312:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S319;
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S316:
  m.FSM_TAKE(7);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);

S319:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S85;
  return m.FSM_HALT(c1);
}

} // namespace ceammc

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace ceammc {

void reflex_code_SMPTE(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if (c1 == '@') goto S14;
  if (c1 == ':') goto S10;
  if ('0' <= c1 && c1 <= '9') goto S7;
  if (c1 == '.') goto S12;
  if ('\v' <= c1) goto S16;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S16;
  return m.FSM_HALT(c1);

S7:
  m.FSM_TAKE(5);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S18;
  return m.FSM_HALT(c1);

S10:
  m.FSM_TAKE(2);
  return m.FSM_HALT();

S12:
  m.FSM_TAKE(3);
  return m.FSM_HALT();

S14:
  m.FSM_TAKE(4);
  return m.FSM_HALT();

S16:
  m.FSM_TAKE(5);
  return m.FSM_HALT();

S18:
  m.FSM_TAKE(1);
  return m.FSM_HALT();
}

} // namespace ceammc

