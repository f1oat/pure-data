// units.lexer.cpp generated by reflex 1.6.3 from units.l

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_freespace           true
#define REFLEX_OPTION_header_file         "units.lexer.h"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               UnitsLexer
#define REFLEX_OPTION_namespace           ceammc::units
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "units.lexer.cpp"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top{ user code %}                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "units.l"

    # include <cerrno>
    # include <cstdlib>
    # include <cstdint>
    # include <cmath>
    # include <array>

    # include "ceammc_log.h"


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace ceammc {
namespace units {

class UnitsLexer : public reflex::AbstractLexer<reflex::Matcher> {
#line 11 "units.l"

    public:
        enum UnitType : uint8_t {
            U_UNKNOWN,
            U_MSEC,
            U_SEC,
            U_MINUTE,
            U_HOUR,
            U_DAY,
            U_SAMP,
            U_HZ,
            U_CENT,
            U_SEMITONE,
            U_TONE,
            U_BPM,
            U_RADIANS,
            U_DEGREE,
            U_DB,
            U_SMPTE,
            U_PERCENT,
            U_RATIO,
            U_PHASE
        };

        enum ValueType : uint8_t {
            T_DOUBLE, T_LONG, T_SMPTE, T_RATIO
        };

        enum Status {
            STATUS_UNKNOWN_TOKEN = -2,
            STATUS_PARSE_ERROR = -1,
            STATUS_EOF = 0,
            STATUS_OK = 1,
            STATUS_CONTINUE
        };

        struct Smpte {
            uint8_t hour;
            uint8_t min;
            uint8_t sec;
            uint8_t frame;

            double toSeconds(double framerate) const {
                return 3600 * hour + 60 * min + sec + (frame / framerate);
            }
        };

        struct Ratio {
            int32_t num;
            int32_t den;
        };

        union Value {
            long int_val;
            double dbl_val;
            Ratio ratio_val;
            Smpte smpte_val;
        };

        struct UnitValue {
            Value val;
            ValueType type;
            UnitType unit = {U_UNKNOWN};
            bool end_offset = {false};
        };

        static constexpr size_t MAX_UNITS = 8;

        struct UnitValues {
            std::array<UnitValue, MAX_UNITS> data;
            size_t n = {1};

            UnitValue& back() { return data[n-1]; }
            void append() { if(n < MAX_UNITS-1) data[n++].val.int_val = 0; }
            void set(double v, UnitType u) { back().val.dbl_val = v; back().unit = u; back().type = T_DOUBLE; }
            void set(long v, UnitType u) { back().val.int_val = v; back().unit = u; back().type = T_LONG; }
            void set(const Smpte& v) { back().val.smpte_val = v; back().unit = U_SMPTE; back().type = T_SMPTE; }
            void set(const Ratio& v) { back().val.ratio_val = v; back().unit = U_RATIO; back().type = T_RATIO; }

            UnitValue& operator[](size_t i) { return data[i]; }
        };

    public:
        UnitValues values;

        int parseSingle()
        {
            values.n = 1;
            int rc = STATUS_OK;
            for(rc = STATUS_OK; rc == STATUS_OK || rc == STATUS_CONTINUE; rc = lex()) {
                if(rc == STATUS_CONTINUE) {
                    // lookup next
                    if (lex() != STATUS_OK) // invalid next token
                       return STATUS_UNKNOWN_TOKEN;

                    // next token is valid, but we are parsing just one
                    values.n = 1;
                    return STATUS_EOF;
                }
            }

            return rc;
        }

        int parseMany()
        {
            values.n = 1;
            int rc;
            for(rc = STATUS_OK; rc == STATUS_OK || rc == STATUS_CONTINUE; rc = lex())
            ;

            return rc;
        }

 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  UnitsLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  virtual int lex();
  int lex(
      const reflex::Input& input,
      std::ostream        *os = NULL)
  {
    in(input);
    if (os)
      out(*os);
    return lex();
  }
};

} // namespace ceammc
} // namespace units

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 132 "units.l"
/*%option debug*/

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace ceammc {
namespace units {
extern void reflex_code_INITIAL(reflex::Matcher&);
} // namespace ceammc
} // namespace units

int ceammc::units::UnitsLexer::lex()
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
#line 298 "units.l"
{   return STATUS_EOF;  }
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 170: (?:[\x09\x0a\x20]+)
#line 170 "units.l"
{   values.append(); return STATUS_CONTINUE; }
            break;
          case 2: // rule at line 171: (?:(?:(?:[\x2b\x2d]?(?:0|[1-9][0-9]*))(?:\.\d+)?)_?%)
#line 171 "units.l"
{
                    auto v = strtod(text(), nullptr);
                    values.set(v, U_PERCENT);
                    return STATUS_OK;
                }
            break;
          case 3: // rule at line 176: (?:(?:(?:[\x2b\x2d]?(?:0|[1-9][0-9]*))(?:\.\d+)?)_?[\x2a])
#line 176 "units.l"
{
                    auto v = strtod(text(), nullptr);
                    values.set(v, U_PHASE);
                    return STATUS_OK;
                }
            break;
          case 4: // rule at line 181: (?:(?:(?:0|[1-9][0-9]*))[/](?:(?:0|[1-9][0-9]*)))
#line 181 "units.l"
{
                    errno = 0;
                    char* endptr = nullptr;
                    const int32_t n = strtol(text(), &endptr, 10);
                    const int32_t d = strtol(endptr+1, nullptr, 10);

                    if (errno)
                        return STATUS_PARSE_ERROR;

                    if (d == 0) {
                        LIB_ERR << "[units] division by zero: " << text();
                        return STATUS_PARSE_ERROR;
                    }

                    values.set(Ratio{n, d});
                    return STATUS_OK;
                }
            break;
          case 5: // rule at line 198: (?:(?:(?:[\x2b\x2d]?(?:0|[1-9][0-9]*))(?:\.\d+)?)_?(?:ms|msec))
#line 198 "units.l"
{
                    const double v = strtod(text(), nullptr);
                    if(!std::isnormal(v) && v != 0)
                        return STATUS_PARSE_ERROR;

                    values.set(v, U_MSEC);
                    return STATUS_OK;
                }
            break;
          case 6: // rule at line 206: (?:[\x2b\x2d]?(?:0|[1-9][0-9]*))
#line 206 "units.l"
{
                    errno = 0;
                    auto v = strtol(text(), nullptr, 10);
                    if (errno)
                        return STATUS_PARSE_ERROR;

                    values.set(v, U_MSEC);
                    return STATUS_OK;
                }
            break;
          case 7: // rule at line 215: (?:(?:[\x2b\x2d]?(?:0|[1-9][0-9]*))_?(?:sa|samp))
#line 215 "units.l"
{
                    errno = 0;
                    auto v = strtol(text(), nullptr, 10);
                    if (errno)
                        return STATUS_PARSE_ERROR;
                    values.set(v, U_SAMP);
                    return STATUS_OK;
                }
            break;
          case 8: // rule at line 223: (?:(?:(?:[\x2b\x2d]?(?:0|[1-9][0-9]*))(?:\.\d+)?)_?(?:s|sec))
#line 223 "units.l"
{
                    auto v = strtod(text(), nullptr);
                    if(!std::isnormal(v) && v != 0)
                        return STATUS_PARSE_ERROR;

                    values.set(v, U_SEC);
                    return STATUS_OK;
                }
            break;
          case 9: // rule at line 231: (?:(?:(?:[\x2b\x2d]?(?:0|[1-9][0-9]*))(?:\.\d+)?)_?min)
#line 231 "units.l"
{
                    auto v = strtod(text(), nullptr);
                    if(!std::isnormal(v) && v != 0)
                        return STATUS_PARSE_ERROR;

                    values.set(v, U_MINUTE);
                    return STATUS_OK;
                }
            break;
          case 10: // rule at line 239: (?:(?:(?:[\x2b\x2d]?(?:0|[1-9][0-9]*))(?:\.\d+)?)_?hz)
#line 239 "units.l"
{
                    auto v = strtod(text(), nullptr);
                    values.set(v, U_HZ);
                    return STATUS_OK;
                }
            break;
          case 11: // rule at line 244: (?:(?:(?:[\x2b\x2d]?(?:0|[1-9][0-9]*))(?:\.\d+)?)_?h)
#line 244 "units.l"
{
                    auto v = strtod(text(), nullptr);
                    values.set(v, U_HOUR);
                    return STATUS_OK;
                }
            break;
          case 12: // rule at line 249: (?:(?:(?:[\x2b\x2d]?(?:0|[1-9][0-9]*))(?:\.\d+)?)_?d)
#line 249 "units.l"
{
                    auto v = strtod(text(), nullptr);
                    values.set(v, U_DAY);
                    return STATUS_OK;
                }
            break;
          case 13: // rule at line 254: (?:(?:(?:[\x2b\x2d]?(?:0|[1-9][0-9]*))(?:\.\d+)?)_?bpm)
#line 254 "units.l"
{
                    auto v = strtod(text(), nullptr);
                    if(!std::isnormal(v) && v != 0)
                        return STATUS_PARSE_ERROR;

                    values.set(v, U_BPM);
                    return STATUS_OK;
                }
            break;
          case 14: // rule at line 262: (?:[0-9]{2}:[0-9]{2}(?::[0-9]{2})?(?:.[0-9]{2})?)
#line 262 "units.l"
{
                    uint8_t d0 = 0; // hour
                    uint8_t d1 = 0; // min
                    uint8_t d2 = 0; // sec
                    uint8_t d3 = 0; // frame
                    char* end = 0;
                    const char* txt = text();
                    d0 = strtol(txt, &end, 10);
                    if (*end == ':') { // 00:
                        d1 = strtol(txt+3, &end, 10);
                        if (*end == ':') { // 00:00:
                            d2 = strtol(txt+6, &end, 10);
                            if (*end == '.') // 00:00:00.
                                d3 = strtol(txt+9, nullptr, 10);
                        } else if(*end == '.') { // 00:00.
                            d3 = strtol(txt+6, nullptr, 10);
                            d2 = d1;
                            d1 = d0;
                            d0 = 0;
                        } else { // 00:00
                            d2 = d1;
                            d1 = d0;
                            d0 = 0;
                        }
                    } else {
                        std::cerr << text() << "\n";
                        return STATUS_PARSE_ERROR;
                        }

                    values.set(Smpte{d0, d1, d2, d3});
                    return STATUS_OK;
                }
            break;
          case 15: // rule at line 294: (?:(?:\$|end)(?=-(?:(?:(?:(?:0|[1-9][0-9]*))_?(?:sa|samp))|(?:(?:(?:0|[1-9][0-9]*)(?:\.\d+)?)_?(?:ms|msec))|(?:(?:(?:0|[1-9][0-9]*)(?:\.\d+)?)_?(?:s|sec))|(?:(?:(?:0|[1-9][0-9]*)(?:\.\d+)?)_?min)|(?:(?:0|[1-9][0-9]*)))))
#line 294 "units.l"
{
                    values.back().end_offset = true;
                    return STATUS_OK;
                }
            break;
          case 16: // rule at line 299: .
#line 299 "units.l"
{   return STATUS_UNKNOWN_TOKEN; }

            break;
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 302 "units.l"


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace ceammc {
namespace units {

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S39;
  if ('1' <= c1 && c1 <= '9') goto S22;
  if (c1 == '0') goto S9;
  if (c1 == '-') goto S48;
  if (c1 == '+') goto S48;
  if (c1 == '$') goto S35;
  if (c1 == ' ') goto S44;
  if ('\t' <= c1 && c1 <= '\n') goto S44;
  if (0 <= c1) goto S42;
  return m.FSM_HALT(c1);

S9:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S62;
  if (c1 == 'm') goto S59;
  if (c1 == 'h') goto S66;
  if (c1 == 'd') goto S69;
  if (c1 == 'b') goto S71;
  if (c1 == '_') goto S77;
  if ('0' <= c1 && c1 <= '9') goto S73;
  if (c1 == '/') goto S56;
  if (c1 == '.') goto S75;
  if (c1 == '*') goto S54;
  if (c1 == '%') goto S52;
  return m.FSM_HALT(c1);

S22:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S62;
  if (c1 == 'm') goto S59;
  if (c1 == 'h') goto S66;
  if (c1 == 'd') goto S69;
  if (c1 == 'b') goto S71;
  if (c1 == '_') goto S77;
  if ('0' <= c1 && c1 <= '9') goto S85;
  if (c1 == '/') goto S56;
  if (c1 == '.') goto S75;
  if (c1 == '*') goto S54;
  if (c1 == '%') goto S52;
  return m.FSM_HALT(c1);

S35:
  m.FSM_TAKE(16);
  m.FSM_HEAD(0);
  c1 = m.FSM_CHAR();
  if (c1 == '-') goto S99;
  return m.FSM_HALT(c1);

S39:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S102;
  return m.FSM_HALT(c1);

S42:
  m.FSM_TAKE(16);
  return m.FSM_HALT();

S44:
  m.FSM_TAKE(1);
  c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S44;
  if ('\t' <= c1 && c1 <= '\n') goto S44;
  return m.FSM_HALT(c1);

S48:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if ('1' <= c1 && c1 <= '9') goto S115;
  if (c1 == '0') goto S104;
  return m.FSM_HALT(c1);

S52:
  m.FSM_TAKE(2);
  return m.FSM_HALT();

S54:
  m.FSM_TAKE(3);
  return m.FSM_HALT();

S56:
  c1 = m.FSM_CHAR();
  if ('1' <= c1 && c1 <= '9') goto S129;
  if (c1 == '0') goto S127;
  return m.FSM_HALT(c1);

S59:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S132;
  if (c1 == 'i') goto S135;
  return m.FSM_HALT(c1);

S62:
  m.FSM_TAKE(8);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S140;
  if (c1 == 'a') goto S137;
  return m.FSM_HALT(c1);

S66:
  m.FSM_TAKE(11);
  c1 = m.FSM_CHAR();
  if (c1 == 'z') goto S142;
  return m.FSM_HALT(c1);

S69:
  m.FSM_TAKE(12);
  return m.FSM_HALT();

S71:
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S144;
  return m.FSM_HALT(c1);

S73:
  c1 = m.FSM_CHAR();
  if (c1 == ':') goto S146;
  return m.FSM_HALT(c1);

S75:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S148;
  return m.FSM_HALT(c1);

S77:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S62;
  if (c1 == 'm') goto S59;
  if (c1 == 'h') goto S66;
  if (c1 == 'd') goto S69;
  if (c1 == 'b') goto S71;
  if (c1 == '*') goto S54;
  if (c1 == '%') goto S52;
  return m.FSM_HALT(c1);

S85:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S62;
  if (c1 == 'm') goto S59;
  if (c1 == 'h') goto S66;
  if (c1 == 'd') goto S69;
  if (c1 == 'b') goto S71;
  if (c1 == '_') goto S77;
  if (c1 == ':') goto S146;
  if ('0' <= c1 && c1 <= '9') goto S158;
  if (c1 == '/') goto S56;
  if (c1 == '.') goto S75;
  if (c1 == '*') goto S54;
  if (c1 == '%') goto S52;
  return m.FSM_HALT(c1);

S99:
  c1 = m.FSM_CHAR();
  if ('1' <= c1 && c1 <= '9') goto S178;
  if (c1 == '0') goto S171;
  return m.FSM_HALT(c1);

S102:
  c1 = m.FSM_CHAR();
  if (c1 == 'd') goto S186;
  return m.FSM_HALT(c1);

S104:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S62;
  if (c1 == 'm') goto S59;
  if (c1 == 'h') goto S66;
  if (c1 == 'd') goto S69;
  if (c1 == 'b') goto S71;
  if (c1 == '_') goto S77;
  if (c1 == '.') goto S75;
  if (c1 == '*') goto S54;
  if (c1 == '%') goto S52;
  return m.FSM_HALT(c1);

S115:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S62;
  if (c1 == 'm') goto S59;
  if (c1 == 'h') goto S66;
  if (c1 == 'd') goto S69;
  if (c1 == 'b') goto S71;
  if (c1 == '_') goto S77;
  if ('0' <= c1 && c1 <= '9') goto S115;
  if (c1 == '.') goto S75;
  if (c1 == '*') goto S54;
  if (c1 == '%') goto S52;
  return m.FSM_HALT(c1);

S127:
  m.FSM_TAKE(4);
  return m.FSM_HALT();

S129:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S129;
  return m.FSM_HALT(c1);

S132:
  m.FSM_TAKE(5);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S189;
  return m.FSM_HALT(c1);

S135:
  c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S191;
  return m.FSM_HALT(c1);

S137:
  m.FSM_TAKE(7);
  c1 = m.FSM_CHAR();
  if (c1 == 'm') goto S193;
  return m.FSM_HALT(c1);

S140:
  c1 = m.FSM_CHAR();
  if (c1 == 'c') goto S195;
  return m.FSM_HALT(c1);

S142:
  m.FSM_TAKE(10);
  return m.FSM_HALT();

S144:
  c1 = m.FSM_CHAR();
  if (c1 == 'm') goto S197;
  return m.FSM_HALT(c1);

S146:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S199;
  return m.FSM_HALT(c1);

S148:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S201;
  if (c1 == 'm') goto S59;
  if (c1 == 'h') goto S66;
  if (c1 == 'd') goto S69;
  if (c1 == 'b') goto S71;
  if (c1 == '_') goto S204;
  if ('0' <= c1 && c1 <= '9') goto S148;
  if (c1 == '*') goto S54;
  if (c1 == '%') goto S52;
  return m.FSM_HALT(c1);

S158:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S62;
  if (c1 == 'm') goto S59;
  if (c1 == 'h') goto S66;
  if (c1 == 'd') goto S69;
  if (c1 == 'b') goto S71;
  if (c1 == '_') goto S77;
  if ('0' <= c1 && c1 <= '9') goto S158;
  if (c1 == '/') goto S56;
  if (c1 == '.') goto S75;
  if (c1 == '*') goto S54;
  if (c1 == '%') goto S52;
  return m.FSM_HALT(c1);

S171:
  m.FSM_TAKE(15);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S212;
  if (c1 == 'm') goto S217;
  if (c1 == '_') goto S220;
  if (c1 == '.') goto S223;
  return m.FSM_HALT(c1);

S178:
  m.FSM_TAKE(15);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S212;
  if (c1 == 'm') goto S217;
  if (c1 == '_') goto S220;
  if ('0' <= c1 && c1 <= '9') goto S178;
  if (c1 == '.') goto S223;
  return m.FSM_HALT(c1);

S186:
  m.FSM_HEAD(0);
  c1 = m.FSM_CHAR();
  if (c1 == '-') goto S99;
  return m.FSM_HALT(c1);

S189:
  c1 = m.FSM_CHAR();
  if (c1 == 'c') goto S225;
  return m.FSM_HALT(c1);

S191:
  m.FSM_TAKE(9);
  return m.FSM_HALT();

S193:
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S227;
  return m.FSM_HALT(c1);

S195:
  m.FSM_TAKE(8);
  return m.FSM_HALT();

S197:
  m.FSM_TAKE(13);
  return m.FSM_HALT();

S199:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S229;
  return m.FSM_HALT(c1);

S201:
  m.FSM_TAKE(8);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S140;
  return m.FSM_HALT(c1);

S204:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S201;
  if (c1 == 'm') goto S59;
  if (c1 == 'h') goto S66;
  if (c1 == 'd') goto S69;
  if (c1 == 'b') goto S71;
  if (c1 == '*') goto S54;
  if (c1 == '%') goto S52;
  return m.FSM_HALT(c1);

S212:
  m.FSM_TAKE(15);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S238;
  if (c1 == 'a') goto S234;
  return m.FSM_HALT(c1);

S217:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S240;
  if (c1 == 'i') goto S244;
  return m.FSM_HALT(c1);

S220:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S212;
  if (c1 == 'm') goto S217;
  return m.FSM_HALT(c1);

S223:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S246;
  return m.FSM_HALT(c1);

S225:
  m.FSM_TAKE(5);
  return m.FSM_HALT();

S227:
  m.FSM_TAKE(7);
  return m.FSM_HALT();

S229:
  m.FSM_TAKE(14);
  c1 = m.FSM_CHAR();
  if (c1 == ':') goto S251;
  if ('\v' <= c1) goto S253;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S253;
  return m.FSM_HALT(c1);

S234:
  m.FSM_TAKE(15);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if (c1 == 'm') goto S255;
  return m.FSM_HALT(c1);

S238:
  c1 = m.FSM_CHAR();
  if (c1 == 'c') goto S257;
  return m.FSM_HALT(c1);

S240:
  m.FSM_TAKE(15);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S260;
  return m.FSM_HALT(c1);

S244:
  c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S257;
  return m.FSM_HALT(c1);

S246:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S262;
  if (c1 == 'm') goto S217;
  if (c1 == '_') goto S266;
  if ('0' <= c1 && c1 <= '9') goto S246;
  return m.FSM_HALT(c1);

S251:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S269;
  return m.FSM_HALT(c1);

S253:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S271;
  return m.FSM_HALT(c1);

S255:
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S257;
  return m.FSM_HALT(c1);

S257:
  m.FSM_TAKE(15);
  m.FSM_TAIL(0);
  return m.FSM_HALT();

S260:
  c1 = m.FSM_CHAR();
  if (c1 == 'c') goto S257;
  return m.FSM_HALT(c1);

S262:
  m.FSM_TAKE(15);
  m.FSM_TAIL(0);
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S238;
  return m.FSM_HALT(c1);

S266:
  c1 = m.FSM_CHAR();
  if (c1 == 's') goto S262;
  if (c1 == 'm') goto S217;
  return m.FSM_HALT(c1);

S269:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S273;
  return m.FSM_HALT(c1);

S271:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S277;
  return m.FSM_HALT(c1);

S273:
  m.FSM_TAKE(14);
  c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S253;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S253;
  return m.FSM_HALT(c1);

S277:
  m.FSM_TAKE(14);
  return m.FSM_HALT();
}

} // namespace ceammc

} // namespace units

