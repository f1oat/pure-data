// math_expr.lexer.cpp generated by reflex 3.0.1 from math_expr.lex

#define REFLEX_VERSION "3.0.1"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_YYLTYPE             ceammc::math::location
#define REFLEX_OPTION_YYSTYPE             ceammc::math::MathExprParser::semantic_type
#define REFLEX_OPTION_bison_cc            true
#define REFLEX_OPTION_bison_cc_namespace  ceammc::math
#define REFLEX_OPTION_bison_cc_parser     MathExprParser
#define REFLEX_OPTION_bison_complete      true
#define REFLEX_OPTION_bison_locations     true
#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_freespace           true
#define REFLEX_OPTION_header_file         "math_expr.lexer.h"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               MathExprLexer
#define REFLEX_OPTION_namespace           ceammc::math
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "math_expr.lexer.cpp"
#define REFLEX_OPTION_reentrant           true
#define REFLEX_OPTION_token_eof           ceammc::math::MathExprParser::symbol_type(0, location())
#define REFLEX_OPTION_token_type          ceammc::math::MathExprParser::symbol_type

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 17 "math_expr.lex"

    # include <cstdlib>

    # include "math_expr.location.hpp"
    # include "math_expr.parser.hpp"

    using token = ceammc::math::MathExprParser::token;


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace ceammc {
namespace math {

class MathExprLexer : public reflex::AbstractLexer<reflex::Matcher> {
 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  MathExprLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  std::string filename;
  virtual ceammc::math::location location(void)
  {
    ceammc::math::location yylloc;
    yylloc.begin.filename = &filename;
    yylloc.begin.line = static_cast<unsigned int>(matcher().lineno());
    yylloc.begin.column = static_cast<unsigned int>(matcher().columno());
    yylloc.end.filename = &filename;
    yylloc.end.line = static_cast<unsigned int>(matcher().lineno_end());
    yylloc.end.column = static_cast<unsigned int>(matcher().columno_end());
    return yylloc;
  }
  virtual ceammc::math::MathExprParser::symbol_type lex(void);
};

} // namespace ceammc
} // namespace math

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "math_expr.lex"
/* math_expr.lex */
#line 15 "math_expr.lex"
/*%option debug*/


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON C++                                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace ceammc {
namespace math {
extern void reflex_code_INITIAL(reflex::Matcher&);
} // namespace ceammc
} // namespace math

ceammc::math::MathExprParser::symbol_type ceammc::math::MathExprLexer::lex(void)
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return ceammc::math::MathExprParser::symbol_type(0, location());
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule math_expr.lex:40: {space} :
#line 40 "math_expr.lex"
{ }

            break;
          case 2: // rule math_expr.lex:42: {bin} :
#line 42 "math_expr.lex"
{ // binary 0x1101101
            return MathExprParser::make_NUM(strtol(text() + 2, NULL, 2), location());
         }

            break;
          case 3: // rule math_expr.lex:46: {hex} :
#line 46 "math_expr.lex"
{ // hex 0xBEEFA24
            return MathExprParser::make_NUM(strtol(text() + 2, NULL, 16), location());
         }

            break;
          case 4: // rule math_expr.lex:50: {double} :
#line 50 "math_expr.lex"
{ // double
            return MathExprParser::make_NUM(strtod(text(), NULL), location());
         }

            break;
          case 5: // rule math_expr.lex:54: {ref} :
#line 54 "math_expr.lex"
{ // refs
            auto n = text()[2];
            return MathExprParser::make_REF(n ? (n - '0') : 0, location());
         }

            break;
          case 6: // rule math_expr.lex:59: "$pi" :
#line 59 "math_expr.lex"
{ return MathExprParser::make_NUM(M_PI, location()); }
            break;
          case 7: // rule math_expr.lex:60: "$e" :
#line 60 "math_expr.lex"
{ return MathExprParser::make_NUM(M_E, location()); }

            break;
          case 8: // rule math_expr.lex:62: {square_open} :
#line 62 "math_expr.lex"
{ return MathExprParser::make_SQR_OPEN(location()); }
            break;
          case 9: // rule math_expr.lex:63: {square_close} :
#line 63 "math_expr.lex"
{ return MathExprParser::make_SQR_CLOSE(location());}
            break;
          case 10: // rule math_expr.lex:64: {par_open} :
#line 64 "math_expr.lex"
{ return MathExprParser::make_PAR_OPEN(location());}
            break;
          case 11: // rule math_expr.lex:65: {par_close} :
#line 65 "math_expr.lex"
{ return MathExprParser::make_PAR_CLOSE(location()); }
            break;
          case 12: // rule math_expr.lex:66: {comma} :
#line 66 "math_expr.lex"
{ return MathExprParser::make_COMMA(location()); }
            break;
          case 13: // rule math_expr.lex:67: "+" :
#line 67 "math_expr.lex"
{ return MathExprParser::make_PLUS(location()); }
            break;
          case 14: // rule math_expr.lex:68: "-" :
#line 68 "math_expr.lex"
{ return MathExprParser::make_MINUS(location()); }
            break;
          case 15: // rule math_expr.lex:69: "*" :
#line 69 "math_expr.lex"
{ return MathExprParser::make_MUL(location()); }
            break;
          case 16: // rule math_expr.lex:70: "/" :
#line 70 "math_expr.lex"
{ return MathExprParser::make_DIV(location()); }
            break;
          case 17: // rule math_expr.lex:71: "%" :
#line 71 "math_expr.lex"
{ return MathExprParser::make_MOD(location()); }
            break;
          case 18: // rule math_expr.lex:72: "^" :
#line 72 "math_expr.lex"
{ return MathExprParser::make_EXP(location()); }
            break;
          case 19: // rule math_expr.lex:73: "==" :
#line 73 "math_expr.lex"
{ return MathExprParser::make_T_EQ(location()); }
            break;
          case 20: // rule math_expr.lex:74: "~=" :
#line 74 "math_expr.lex"
{ return MathExprParser::make_T_APPROX_EQ(location()); }
            break;
          case 21: // rule math_expr.lex:75: "!=" :
#line 75 "math_expr.lex"
{ return MathExprParser::make_T_NOT_EQ(location()); }
            break;
          case 22: // rule math_expr.lex:76: "<=" :
#line 76 "math_expr.lex"
{ return MathExprParser::make_T_LE(location()); }
            break;
          case 23: // rule math_expr.lex:77: "<" :
#line 77 "math_expr.lex"
{ return MathExprParser::make_T_LT(location()); }
            break;
          case 24: // rule math_expr.lex:78: ">=" :
#line 78 "math_expr.lex"
{ return MathExprParser::make_T_GE(location()); }
            break;
          case 25: // rule math_expr.lex:79: ">" :
#line 79 "math_expr.lex"
{ return MathExprParser::make_T_GT(location()); }

            break;
          case 26: // rule math_expr.lex:81: {symbol}/({par_open}|{square_open}) :
#line 81 "math_expr.lex"
{
                  return MathExprParser::make_SYMBOL(text(), location()); }

            break;
          case 27: // rule math_expr.lex:84: . :
#line 84 "math_expr.lex"
{ return MathExprParser::make_LEXER_ERROR(location());}

            break;
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace ceammc {
namespace math {

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if (c1 == '~') goto S63;
  if ('a' <= c1 && c1 <= 'z') goto S75;
  if (c1 == '^') goto S58;
  if (c1 == ']') goto S40;
  if (c1 == '[') goto S38;
  if ('A' <= c1 && c1 <= 'Z') goto S75;
  if (c1 == '>') goto S72;
  if (c1 == '=') goto S60;
  if (c1 == '<') goto S69;
  if ('1' <= c1 && c1 <= '9') goto S87;
  if (c1 == '0') goto S27;
  if (c1 == '/') goto S54;
  if (c1 == '.') goto S91;
  if (c1 == '-') goto S50;
  if (c1 == ',') goto S46;
  if (c1 == '+') goto S48;
  if (c1 == '*') goto S52;
  if (c1 == ')') goto S44;
  if (c1 == '(') goto S42;
  if (c1 == '%') goto S56;
  if (c1 == '$') goto S33;
  if (c1 == '!') goto S66;
  if (c1 == ' ') goto S83;
  if ('\v' <= c1) goto S81;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (c1 == '\t') goto S83;
  if (0 <= c1 && c1 <= '\b') goto S81;
  return m.FSM_HALT(c1);

S27:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if (c1 == 'x') goto S96;
  if (c1 == 'b') goto S94;
  if ('0' <= c1 && c1 <= '9') goto S87;
  if (c1 == '.') goto S100;
  return m.FSM_HALT(c1);

S33:
  m.FSM_TAKE(27);
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S105;
  if (c1 == 'f') goto S102;
  if (c1 == 'e') goto S107;
  return m.FSM_HALT(c1);

S38:
  m.FSM_TAKE(8);
  return m.FSM_HALT();

S40:
  m.FSM_TAKE(9);
  return m.FSM_HALT();

S42:
  m.FSM_TAKE(10);
  return m.FSM_HALT();

S44:
  m.FSM_TAKE(11);
  return m.FSM_HALT();

S46:
  m.FSM_TAKE(12);
  return m.FSM_HALT();

S48:
  m.FSM_TAKE(13);
  return m.FSM_HALT();

S50:
  m.FSM_TAKE(14);
  return m.FSM_HALT();

S52:
  m.FSM_TAKE(15);
  return m.FSM_HALT();

S54:
  m.FSM_TAKE(16);
  return m.FSM_HALT();

S56:
  m.FSM_TAKE(17);
  return m.FSM_HALT();

S58:
  m.FSM_TAKE(18);
  return m.FSM_HALT();

S60:
  m.FSM_TAKE(27);
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S109;
  return m.FSM_HALT(c1);

S63:
  m.FSM_TAKE(27);
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S111;
  return m.FSM_HALT(c1);

S66:
  m.FSM_TAKE(27);
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S113;
  return m.FSM_HALT(c1);

S69:
  m.FSM_TAKE(23);
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S115;
  return m.FSM_HALT(c1);

S72:
  m.FSM_TAKE(25);
  c1 = m.FSM_CHAR();
  if (c1 == '=') goto S117;
  return m.FSM_HALT(c1);

S75:
  m.FSM_TAKE(27);
  c1 = m.FSM_CHAR();
  if ('^' <= c1) goto S119;
  if (c1 == '\\') goto S119;
  if ('*' <= c1 && c1 <= 'Z') goto S119;
  if ('(' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\'') goto S119;
  return m.FSM_HALT(c1);

S81:
  m.FSM_TAKE(27);
  return m.FSM_HALT();

S83:
  m.FSM_TAKE(1);
  c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S83;
  if (c1 == '\t') goto S83;
  return m.FSM_HALT(c1);

S87:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S87;
  if (c1 == '.') goto S100;
  return m.FSM_HALT(c1);

S91:
  m.FSM_TAKE(27);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S126;
  return m.FSM_HALT(c1);

S94:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '1') goto S129;
  return m.FSM_HALT(c1);

S96:
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'f') goto S132;
  if ('A' <= c1 && c1 <= 'F') goto S132;
  if ('0' <= c1 && c1 <= '9') goto S132;
  return m.FSM_HALT(c1);

S100:
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S126;
  return m.FSM_HALT(c1);

S102:
  m.FSM_TAKE(5);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S102;
  return m.FSM_HALT(c1);

S105:
  c1 = m.FSM_CHAR();
  if (c1 == 'i') goto S137;
  return m.FSM_HALT(c1);

S107:
  m.FSM_TAKE(7);
  return m.FSM_HALT();

S109:
  m.FSM_TAKE(19);
  return m.FSM_HALT();

S111:
  m.FSM_TAKE(20);
  return m.FSM_HALT();

S113:
  m.FSM_TAKE(21);
  return m.FSM_HALT();

S115:
  m.FSM_TAKE(22);
  return m.FSM_HALT();

S117:
  m.FSM_TAKE(24);
  return m.FSM_HALT();

S119:
  m.FSM_HEAD(0);
  c1 = m.FSM_CHAR();
  if ('^' <= c1) goto S119;
  if (c1 == '[') goto S139;
  if ('*' <= c1 && c1 <= '\\') goto S119;
  if (')' <= c1) return m.FSM_HALT(c1);
  if (c1 == '(') goto S139;
  if (0 <= c1 && c1 <= '\'') goto S119;
  return m.FSM_HALT(c1);

S126:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S126;
  return m.FSM_HALT(c1);

S129:
  m.FSM_TAKE(2);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '1') goto S129;
  return m.FSM_HALT(c1);

S132:
  m.FSM_TAKE(3);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'f') goto S132;
  if ('A' <= c1 && c1 <= 'F') goto S132;
  if ('0' <= c1 && c1 <= '9') goto S132;
  return m.FSM_HALT(c1);

S137:
  m.FSM_TAKE(6);
  return m.FSM_HALT();

S139:
  m.FSM_TAKE(26);
  m.FSM_TAIL(0);
  return m.FSM_HALT();
}

} // namespace ceammc

} // namespace math

